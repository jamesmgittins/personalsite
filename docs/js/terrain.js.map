{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"THREE\"","webpack:///./src/ts/terrain/constants.ts","webpack:///./src/ts/terrain/utils.ts","webpack:///./src/ts/game/gamemodel.ts","webpack:///./src/index.ts","webpack:///./src/ts/terrain/terrain.ts","webpack:///./src/ts/shaders.ts","webpack:///./src/ts/terrain/terrain.worker.ts","webpack:///./src/ts/game/camera.ts","webpack:///./src/ts/game/controls.ts","webpack:///./src/ts/game/vehicles.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","heights","water","sand","plainsMin","plainsMax","mountainFactor","mountainMod","chunkSize","x","y","chunkRange","noiseSeed","maximumTrees","maximumGrass","heightAdjustment","height","noise","simplex2","plainsHeight","Math","pow","max","snowMod","gravelMod","greenColor","Color","brownColor","geo","Geometry","level1","ConeGeometry","faces","forEach","f","color","set","translate","merge","level2","level3","trunk","CylinderGeometry","bufferGeo","BufferGeometry","fromGeometry","model","settings","terrainSettings","settingsChanged","Constants","detailSettings","treeNumber","grassNumber","grassDensity","rendererSettings","antialias","resolution","seedSettings","seed","startApplication","gameModel","getGameModel","scene","Scene","camera","Camera","MyCamera","controls","Controls","renderer","WebGLRenderer","terrain","Terrain","document","getElementById","classList","add","setSize","window","innerWidth","innerHeight","background","appendChild","domElement","sunGroup","Group","sunLightColor","dirLight","DirectionalLight","position","z","target","currTime","lastTime","animate","requestAnimationFrame","console","log","setPixelRatio","Date","now","timeDiff","min","updateChunks","handleMovement","render","onresize","aspect","updateProjectionMatrix","grassTexture","TextureLoader","load","grassBladeTexture","grassBladeTexture2","grassBladeTexture3","gravelTexture","sandTexture","waterTexture","snowTexture","wrapS","MirroredRepeatWrapping","wrapT","RepeatWrapping","magFilter","NearestFilter","uniforms","UniformsUtils","ShaderLib","phong","texture1","type","time","amp","waterMaterial","ShaderMaterial","vertexShader","MyShaders","WaterVertexShader","fragmentShader","WaterFragmentShader","lights","transparent","alphaTest","landUniforms","standard","grassUniforms","lambert","texture2","texture3","maxDistance","treeUniforms","landMaterial","LandVertexShader","LandFragmentShader","side","BackSide","waterGeometry","PlaneBufferGeometry","waterPlane","Mesh","rotation","PI","staticWaterGeo","staticWater","MeshPhongMaterial","map","WorkerPool","maxWorkers","onMessage","workers","counter","this","length","worker","onmessage","push","Chunk","size","planeMesh","discarded","callback","chunks","chunkMap","discardedChunks","maxTreeDistance","maxGrassDistance","called","lastCubeCenter","lastGrassCenter","group","waterGroup","terrainGroup","grassMesh","InstancedMesh","DoubleSide","GrassVertexShader","GrassFragmentShader","getGrassMesh","treeMesh","getTreeGeometery","vertexColors","TreeVertexShader","TreeFragmentShader","that","workerPool","event","data","processGrass","grassMatrices","grassTextures","processTrees","treeMatrices","processChunk","pa","landTextures","chunk","pop","processed","computeBoundingSphere","computeVertexNormals","foreignChunk","foreignNormals","foreignIndex","hVerts","wVerts","normals","getAttribute","setXYZ","getX","getY","getZ","needsUpdate","grassTextureArray","Float32Array","count","instanceMatrix","copyArray","geometry","setAttribute","InstancedBufferAttribute","treeMatrixArray","paData","visible","BufferAttribute","fixChunkNormals","createChunkObject","getWorker","postMessage","keys","updateUniforms","offsetX","round","offsetY","abs","centerChunk","minX","maxX","minY","maxY","destroyChunk","splice","j","createChunk2","Worker","PerspectiveCamera","myCamera","flashLight","vehicleWalking","Walking","currentVehicle","Vehicle","super","speed","Vector2","preferredZoom","getHeight","diff"],"mappings":"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","file":"terrain.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = THREE;","export const heights = {\r\n    water: 4.3,\r\n    sand: 5.0,\r\n    plainsMin: 4,\r\n    plainsMax: 35,\r\n    mountainFactor : 1.6\r\n}\r\nexport const mountainMod = heights.plainsMax - (heights.plainsMin + ((heights.plainsMax - heights.plainsMin) / 4));\r\nexport const chunkSize = { x: 128, y: 128 };\r\nexport const chunkRange = 3;\r\nexport const noiseSeed = 1024;\r\nexport const maximumTrees = 500;\r\nexport const maximumGrass = 2000;","import {heights, mountainMod} from './constants';\r\n\r\nconst heightAdjustment = heights.plainsMin + ((heights.plainsMax - heights.plainsMin) / 4);\r\n\r\nexport function getHeight(x : number, y : number) {\r\n    let height =\r\n        0.5 * noise.simplex2(x / 8,   y / 8) +\r\n        2   * noise.simplex2(x / 32,  y / 32) +\r\n        10  * noise.simplex2(x / 100, y / 100) +\r\n        32  * noise.simplex2(x / 200, y / 200) +\r\n        32  * noise.simplex2(x / 500, y / 500) +\r\n        24  * noise.simplex2(x / 900, y / 900);\r\n\r\n    height += 30;\r\n        \r\n    let plainsHeight = heights.plainsMin + ((height - heights.plainsMin) / 4);\r\n\r\n    if (height > heights.plainsMax) {\r\n        return Math.pow(plainsHeight - heightAdjustment, heights.mountainFactor) + heightAdjustment;\r\n    }\r\n    return plainsHeight;\r\n}\r\n\r\nexport function getLandTexture(x : number, y : number, height : number) {\r\n\r\n    if (height < heights.water - 1) {\r\n        return 0 + Math.max(height - (heights.water - 2), 0);\r\n        // return 0;\r\n    }\r\n    if (height < heights.sand + 0.5){\r\n        return 1;\r\n    }\r\n    if (height < heights.sand + 1.0)\r\n        return 1 + 2 * (height - (heights.sand + 0.5));\r\n    let snowMod = 3 + (3 * noise.simplex2(x / 20, y / 20));\r\n    if (height > heights.plainsMax + 5 + snowMod)\r\n        return 4;\r\n    if (height > heights.plainsMax + 3.0 + snowMod)\r\n        return 3 + ((height - (heights.plainsMax + 3.0 + snowMod)) * 0.5);\r\n    let gravelMod = 5 + (5 * noise.simplex2(x / 15, y / 15));\r\n    if (height > mountainMod + gravelMod)\r\n        return 3;\r\n    if (height > mountainMod + gravelMod - 2) {\r\n        return 2 + ((height - (mountainMod + gravelMod - 2)) * 0.5);\r\n    }\r\n    return 2;\r\n}\r\n\r\nexport function getTreeGeometery() : THREE.BufferGeometry {\r\n    const greenColor = new THREE.Color(0x317830);\r\n    const brownColor = new THREE.Color(0x6e3626);\r\n    const geo = new THREE.Geometry();\r\n    const level1 = new THREE.ConeGeometry(0.8,1.6,10);\r\n    level1.faces.forEach(f => f.color.set(greenColor));\r\n    level1.translate(0,3.7,0);\r\n    geo.merge(level1);\r\n    const level2 = new THREE.ConeGeometry(1.0,1.8,10);\r\n    level2.faces.forEach(f => f.color.set(greenColor));\r\n    level2.translate(0,2.9,0);\r\n    geo.merge(level2);\r\n    const level3 = new THREE.ConeGeometry(1.2,2,10);\r\n    level3.faces.forEach(f => f.color.set(greenColor));\r\n    level3.translate(0,2,0);\r\n    geo.merge(level3);\r\n    const trunk = new THREE.CylinderGeometry(0.3,0.3,2);\r\n    trunk.translate(0, -0.0, 0);\r\n    trunk.faces.forEach(f => f.color.set(brownColor));\r\n    geo.merge(trunk);\r\n    let bufferGeo = new THREE.BufferGeometry();\r\n    bufferGeo.fromGeometry(geo);\r\n    return bufferGeo;\r\n}\r\n\r\n// export function isWater(height : number) : boolean {\r\n//     return height < heights.water + 0.55;\r\n// }","import * as Constants from '../terrain/constants';\r\n\r\nclass GameModel {\r\n\r\n    public settings = {\r\n        terrainSettings : {\r\n            settingsChanged : false,\r\n            chunkSize : Constants.chunkSize.x,\r\n            chunkRange : 5\r\n        },\r\n        detailSettings : {\r\n            settingsChanged : false,\r\n            treeNumber : 1000,\r\n            grassNumber : 20000,\r\n            grassDensity : 0.25\r\n        },\r\n        rendererSettings : {\r\n            settingsChanged : false,\r\n            antialias : false,\r\n            resolution : 1.0\r\n        },\r\n        seedSettings : {\r\n            seed : Constants.noiseSeed,\r\n            settingsChanged : false\r\n        }\r\n    }\r\n}\r\n\r\nconst model = new GameModel();\r\n\r\nexport function getGameModel() : GameModel {\r\n    return model;\r\n}","// three.js\r\nimport * as THREE from 'three';\r\nimport * as Terrain from './ts/terrain/terrain';\r\nimport * as Camera from './ts/game/camera';\r\nimport { Controls } from './ts/game/controls';\r\nimport { getGameModel } from './ts/game/gamemodel';\r\n\r\nexport function startApplication() {\r\n  const gameModel = getGameModel();\r\n\r\n  // create the scene\r\n  const scene = new THREE.Scene();\r\n\r\n  // create the camera and controls\r\n  const camera = new Camera.MyCamera(scene);\r\n  const controls = new Controls(camera);\r\n  const renderer = new THREE.WebGLRenderer({ antialias: false });\r\n\r\n  // terrain\r\n  let terrain = new Terrain.Terrain(scene, () => {\r\n    document.getElementById('canvas-container').classList.add('ready');\r\n  });\r\n\r\n  // set size\r\n  renderer.setSize(window.innerWidth, window.innerHeight);\r\n  scene.background = new THREE.Color(0, 0, 0);\r\n\r\n  // add canvas to dom\r\n  document.getElementById('canvas-container').appendChild(renderer.domElement);\r\n\r\n  // setup lights\r\n\r\n  let sunGroup = new THREE.Group();\r\n  scene.add(sunGroup);\r\n\r\n  const sunMax = 0.6;\r\n  const sunLightColor = new THREE.Color(0xFFFFDD);\r\n  let dirLight = new THREE.DirectionalLight(sunLightColor, sunMax);\r\n  dirLight.position.y = 3000;\r\n  dirLight.position.z = 1000;\r\n  dirLight.target = camera.camera;\r\n  sunGroup.add(dirLight);\r\n\r\n  function animate(): void {\r\n    requestAnimationFrame(animate);\r\n    render();\r\n  }\r\n\r\n  let currTime = 0, lastTime = 0;\r\n\r\n  function render(): void {\r\n\r\n    if (gameModel.settings.rendererSettings.settingsChanged) {\r\n      console.log(\"render settings changed\");\r\n      renderer.setPixelRatio(gameModel.settings.rendererSettings.resolution);\r\n      gameModel.settings.rendererSettings.settingsChanged = false;\r\n    }\r\n\r\n    currTime = Date.now();\r\n    let timeDiff = Math.min((currTime - lastTime) / 1000, 1);\r\n    lastTime = currTime;\r\n    terrain.updateChunks(timeDiff, camera.camera);\r\n    controls.handleMovement(timeDiff);\r\n    renderer.render(scene, camera.camera);\r\n  }\r\n\r\n  animate();\r\n\r\n  window.onresize = function () {\r\n    camera.camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.camera.updateProjectionMatrix();\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n  };\r\n\r\n}\r\n\r\nstartApplication();","// three.js\r\nimport * as THREE from 'three';\r\nimport {MyShaders} from \"../shaders\";\r\nimport MyWorker from './terrain.worker';\r\nimport {heights} from './constants';\r\nimport {getTreeGeometery} from './utils';\r\nimport { getGameModel } from '../game/gamemodel';\r\n\r\nconst gameModel = getGameModel();\r\nnoise.seed(gameModel.settings.seedSettings.seed);\r\nconst grassTexture = new THREE.TextureLoader().load('img/grass.png');\r\nconst grassBladeTexture = new THREE.TextureLoader().load('img/grassblade.png');\r\nconst grassBladeTexture2 = new THREE.TextureLoader().load('img/grassblade2.png');\r\nconst grassBladeTexture3 = new THREE.TextureLoader().load('img/grassblade3.png');\r\nconst gravelTexture = new THREE.TextureLoader().load('img/gravel.png');\r\nconst sandTexture = new THREE.TextureLoader().load('img/sand.png');\r\nconst waterTexture = new THREE.TextureLoader().load('img/water.jpg');\r\nconst snowTexture = new THREE.TextureLoader().load('img/snow.png');\r\nwaterTexture.wrapS = THREE.MirroredRepeatWrapping;\r\nwaterTexture.wrapT = THREE.MirroredRepeatWrapping;\r\nwaterTexture.wrapT = THREE.RepeatWrapping;\r\ngravelTexture.wrapS = snowTexture.wrapS = sandTexture.wrapS = grassTexture.wrapS = THREE.RepeatWrapping;\r\ngravelTexture.wrapT = snowTexture.wrapT = sandTexture.wrapT = grassTexture.wrapT = THREE.RepeatWrapping;\r\ngravelTexture.magFilter = snowTexture.magFilter = sandTexture.magFilter = grassTexture.magFilter = THREE.NearestFilter;\r\n\r\nconst uniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.phong.uniforms]);\r\nuniforms.texture1 = { type: \"t\", value: waterTexture };\r\nuniforms.time = { type: \"f\", value: 1.0 };\r\nuniforms.amp = { type: \"f\", value: 0.004 };\r\n\r\nconst waterMaterial = new THREE.ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: MyShaders.WaterVertexShader,\r\n    fragmentShader: MyShaders.WaterFragmentShader,\r\n    lights: true, transparent : true, alphaTest : 0.5,\r\n});\r\n\r\nconst landUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.standard.uniforms]);\r\nlandUniforms.grassTexture = { type: \"t\", value: grassTexture };\r\nlandUniforms.sandTexture = { type: \"t\", value: sandTexture };\r\nlandUniforms.snowTexture = { type: \"t\", value: snowTexture };\r\nlandUniforms.gravelTexture = { type: \"t\", value: gravelTexture };\r\n\r\nconst grassUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.lambert.uniforms]);\r\ngrassUniforms.texture1 = { type: \"t\", value: grassBladeTexture };\r\ngrassUniforms.texture2 = { type: \"t\", value: grassBladeTexture2 };\r\ngrassUniforms.texture3 = { type: \"t\", value: grassBladeTexture3 };\r\ngrassUniforms.time = { type: \"f\", value: 0 };\r\ngrassUniforms.amp = { type: \"f\", value: 0.5 };\r\ngrassUniforms.maxDistance = { type : \"f\", value : 30};\r\n\r\nconst treeUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.lambert.uniforms]);\r\ntreeUniforms.time = { type: \"f\", value: 0 };\r\ntreeUniforms.amp = { type: \"f\", value: 0.05 };\r\ntreeUniforms.maxDistance = { type : \"f\", value : 30};\r\n\r\nfunction getGrassMesh() : THREE.InstancedMesh {\r\n    let geo = new THREE.PlaneBufferGeometry(0.5, 0.5);\r\n    \r\n    return new THREE.InstancedMesh( geo, \r\n        new THREE.ShaderMaterial({ \r\n            uniforms : grassUniforms, \r\n            side : THREE.DoubleSide, \r\n            vertexShader : MyShaders.GrassVertexShader,\r\n            fragmentShader : MyShaders.GrassFragmentShader,\r\n            transparent : true, alphaTest : 0.5, \r\n            lights : true\r\n        }), \r\n        gameModel.settings.detailSettings.grassNumber);\r\n}\r\n\r\nfunction getTreeMesh() : THREE.InstancedMesh {\r\n    return new THREE.InstancedMesh( getTreeGeometery(), \r\n        new THREE.ShaderMaterial({\r\n            uniforms : treeUniforms,\r\n            vertexColors: true, \r\n            vertexShader : MyShaders.TreeVertexShader,\r\n            fragmentShader : MyShaders.TreeFragmentShader,\r\n            lights : true, transparent : true, alphaTest : 0.5,\r\n        }),\r\n        gameModel.settings.detailSettings.treeNumber);\r\n}\r\n\r\nlet landMaterial = new THREE.ShaderMaterial({\r\n    uniforms: landUniforms,\r\n    vertexShader: MyShaders.LandVertexShader,\r\n    fragmentShader: MyShaders.LandFragmentShader,\r\n    lights: true, side : THREE.BackSide\r\n});\r\n\r\nvar waterGeometry = new THREE.PlaneBufferGeometry(4000, 4000, 1, 1);\r\nvar waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);\r\nwaterPlane.position.y = heights.water + 0.55;\r\nwaterPlane.rotation.x = -0.5 * Math.PI;\r\nvar staticWaterGeo = new THREE.PlaneBufferGeometry(6400, 6400, 1, 1);\r\nvar staticWater = new THREE.Mesh(staticWaterGeo, new THREE.MeshPhongMaterial({ map: waterTexture }));\r\nstaticWater.position.y = heights.water + 0.5;\r\nstaticWater.rotation.x = -0.5 * Math.PI;\r\n\r\nexport function isWater(height : number) : boolean {\r\n    return height < waterPlane.position.y;\r\n}\r\n\r\nclass WorkerPool {\r\n    private workers : Worker[] = [];\r\n    private counter : number = 0;\r\n    private maxWorkers : number = 1;\r\n    private onMessage : (event : MessageEvent) => void;\r\n    constructor(maxWorkers : number, onMessage :  (event : MessageEvent) => void) {\r\n        this.maxWorkers = maxWorkers;\r\n        this.onMessage = onMessage;\r\n    }\r\n    public getWorker() : Worker {\r\n        if (this.workers.length < this.maxWorkers) {\r\n            let worker = new MyWorker();\r\n            worker.onmessage = this.onMessage;\r\n            this.workers.push(worker);\r\n        }\r\n        this.counter++;\r\n        if (this.counter > this.workers.length - 1) {\r\n            this.counter = 0;\r\n        }\r\n        return this.workers[this.counter];        \r\n    }\r\n}\r\n\r\nclass Chunk {\r\n    public x : number;\r\n    public y : number;\r\n    public geo: THREE.PlaneBufferGeometry;\r\n    public planeMesh : THREE.Mesh;\r\n    public discarded : boolean;\r\n    public processed : boolean;\r\n    constructor(x : number, y : number, size : number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.geo = new THREE.PlaneBufferGeometry(size, size, size, size);\r\n        this.planeMesh = new THREE.Mesh(this.geo, landMaterial);\r\n        this.discarded = false;\r\n    }\r\n}\r\n\r\nexport class Terrain {\r\n\r\n    public chunkRange : number = 1;\r\n    public chunkSize : number = 32;\r\n    private chunks : Chunk[] = [];\r\n    private chunkMap : Chunk[][] = [];\r\n    private discardedChunks : Chunk[] = [];\r\n    private group : THREE.Group;\r\n    private waterGroup : THREE.Group;\r\n    private terrainGroup : THREE.Group;\r\n    private workerPool : WorkerPool;\r\n    private grassMesh : THREE.InstancedMesh;\r\n    private treeMesh : THREE.InstancedMesh;\r\n    private maxTreeDistance : number = 0;\r\n    private maxGrassDistance : number = 0;\r\n    private maxWorkers = 3;\r\n    private called : boolean = false;\r\n    private callback : () => void;\r\n\r\n    constructor(scene : THREE.Scene, callback : () => void) {\r\n        this.chunkRange = gameModel.settings.terrainSettings.chunkRange;\r\n        this.chunkSize = gameModel.settings.terrainSettings.chunkSize;\r\n        this.group = new THREE.Group();\r\n        scene.add(this.group);\r\n        this.waterGroup = new THREE.Group();\r\n        this.waterGroup.add(waterPlane);\r\n        this.group.add(this.waterGroup);\r\n        this.terrainGroup = new THREE.Group();\r\n        this.group.add(this.terrainGroup);\r\n        this.grassMesh = getGrassMesh();\r\n        this.terrainGroup.add(this.grassMesh);\r\n        this.treeMesh = getTreeMesh();\r\n        this.terrainGroup.add(this.treeMesh);\r\n        this.callback = callback;\r\n        let that = this;\r\n        this.workerPool = new WorkerPool(this.maxWorkers, function(event : MessageEvent) {\r\n            switch(event.data.type) {\r\n                case \"grass\":\r\n                    that.maxGrassDistance = event.data.maxDistance;\r\n                    that.processGrass(event.data.grassMatrices, event.data.grassTextures);\r\n                    break;\r\n                case \"tree\":\r\n                    that.maxTreeDistance = event.data.maxDistance;\r\n                    that.processTrees(event.data.treeMatrices);\r\n                    break;\r\n                case \"land\":\r\n                    that.processChunk(event.data.x, event.data.y, event.data.pa, event.data.landTextures, event.data.size);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private createChunkObject (x : number, y : number) {\r\n        if (this.discardedChunks.length > 0) {\r\n            let chunk = this.discardedChunks.pop();\r\n            chunk.x = x;\r\n            chunk.y = y;\r\n            chunk.discarded = false;\r\n            chunk.processed = false;\r\n            return chunk;\r\n        }\r\n        let chunk = new Chunk(x , y, this.chunkSize);\r\n        this.terrainGroup.add(chunk.planeMesh);\r\n        chunk.processed = false;\r\n        return chunk;\r\n    }\r\n\r\n    private fixChunkNormals (chunk : Chunk) {\r\n        chunk.geo.computeBoundingSphere();\r\n        chunk.geo.computeVertexNormals();\r\n\r\n        let hVerts = this.chunkSize + 1;\r\n        let wVerts = this.chunkSize + 1;\r\n        let normals = chunk.geo.getAttribute(\"normal\");\r\n\r\n        let foreignChunk : Chunk\r\n        let foreignNormals : THREE.BufferAttribute | THREE.InterleavedBufferAttribute;\r\n        let foreignIndex : number;\r\n        if (this.chunkMap[chunk.x - this.chunkSize] && this.chunkMap[chunk.x - this.chunkSize][chunk.y]) {  // left side exists j = 0, i changes\r\n            foreignChunk = this.chunkMap[chunk.x - this.chunkSize][chunk.y];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < wVerts; i++) {\r\n                    foreignIndex = (hVerts - 1) * wVerts + i;\r\n                    normals.setXYZ(i, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x + this.chunkSize] && this.chunkMap[chunk.x + this.chunkSize][chunk.y]) {  // right side exists j = wVerts - 1, i changes\r\n            foreignChunk = this.chunkMap[chunk.x + this.chunkSize][chunk.y];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < wVerts; i++) {\r\n                    foreignIndex = i;\r\n                    normals.setXYZ((hVerts - 1) * wVerts + i, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x] && this.chunkMap[chunk.x][chunk.y + this.chunkSize]) {  // top side exists i = 0, j changes\r\n            foreignChunk = this.chunkMap[chunk.x][chunk.y + this.chunkSize];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < hVerts; i++) {\r\n                    foreignIndex = i * wVerts;\r\n                    normals.setXYZ(i * wVerts + (hVerts - 1), foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x] && this.chunkMap[chunk.x][chunk.y - this.chunkSize]) {  // bottom side exists i = hVerts - 1, j changes\r\n            foreignChunk = this.chunkMap[chunk.x][chunk.y - this.chunkSize];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < hVerts; i++) {\r\n                    foreignIndex = i * wVerts + (hVerts - 1);\r\n                    normals.setXYZ(i * wVerts, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n        let pos = chunk.geo.getAttribute(\"position\") as THREE.BufferAttribute;\r\n        pos.needsUpdate = true;\r\n    }\r\n\r\n    private processGrass(grassMatrices : [], grassTextures : []) {\r\n        let grassTextureArray = new Float32Array(grassTextures);\r\n        if (this.grassMesh.count < grassTextureArray.length)\r\n            return;\r\n        this.grassMesh.instanceMatrix.copyArray(new Float32Array(grassMatrices));\r\n        (this.grassMesh.geometry as THREE.PlaneBufferGeometry).setAttribute( 'tex', new THREE.InstancedBufferAttribute(grassTextureArray, 1, false, 1) );\r\n        this.grassMesh.instanceMatrix.needsUpdate = true;\r\n        this.treeMesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    private processTrees(treeMatrices : []) {\r\n        let treeMatrixArray = new Float32Array(treeMatrices);\r\n        if (this.treeMesh.count < treeMatrixArray.length / 16)\r\n            return;\r\n        this.treeMesh.instanceMatrix.copyArray(treeMatrixArray);\r\n        this.treeMesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    private processChunk(x : number, y : number, paData : [], landTextures : [],  size : number) {\r\n        if (size != this.chunkSize || !this.chunkMap[x] || !this.chunkMap[x][y])\r\n            return;\r\n\r\n        let chunk = this.chunkMap[x][y];\r\n        chunk.planeMesh.visible = false;\r\n        chunk.geo.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(paData), 3, false));\r\n        chunk.geo.setAttribute(\"tex\", new THREE.BufferAttribute(new Float32Array(landTextures), 1, false));\r\n        this.fixChunkNormals(chunk);\r\n        chunk.processed = true;\r\n        chunk.planeMesh.visible = true;\r\n    }\r\n\r\n    private createChunk2 (x : number, y : number) {\r\n        let chunk = this.createChunkObject(x, y);\r\n        this.workerPool.getWorker().postMessage([\"land\", x, y, this.chunkSize]);\r\n        \r\n        this.chunks.push(chunk);\r\n        if (!this.chunkMap[x])\r\n            this.chunkMap[x] = [];\r\n\r\n        this.chunkMap[x][y] = chunk;\r\n    }\r\n\r\n    private destroyChunk(chunk : Chunk) {\r\n        chunk.discarded = true;\r\n        this.discardedChunks.push(chunk);\r\n        delete this.chunkMap[chunk.x][chunk.y];\r\n        if (Object.keys(this.chunkMap[chunk.x]).length == 0)\r\n            delete this.chunkMap[chunk.x];\r\n    }\r\n\r\n    private lastCubeCenter = { x: 1, y: 1 };\r\n    private lastGrassCenter = {x : 0, y: 0};\r\n\r\n    private updateUniforms(timeDiff : number) {\r\n        uniforms.time.value += timeDiff * 60;\r\n        grassUniforms.time.value += timeDiff * 60;\r\n        if (grassUniforms.maxDistance.value > this.maxGrassDistance) {\r\n            grassUniforms.maxDistance.value -= 10 * timeDiff;\r\n        }\r\n        if (grassUniforms.maxDistance.value < this.maxGrassDistance) {\r\n            grassUniforms.maxDistance.value += 10 * timeDiff;\r\n        }\r\n        treeUniforms.time.value += timeDiff * 60;\r\n        if (treeUniforms.maxDistance.value > this.maxTreeDistance) {\r\n            treeUniforms.maxDistance.value -= 10 * timeDiff;\r\n        }\r\n        if (treeUniforms.maxDistance.value < this.maxTreeDistance) {\r\n            treeUniforms.maxDistance.value += 10 * timeDiff;\r\n        }\r\n    }\r\n\r\n    public updateChunks(timeDiff : number, camera : THREE.Camera) {\r\n        this.updateUniforms(timeDiff);\r\n        let offsetX = Math.round(camera.position.x);\r\n        let offsetY = Math.round(camera.position.z);\r\n        if (Math.abs(offsetX - this.waterGroup.position.x) > 64 || Math.abs(offsetY - this.waterGroup.position.z) > 64) {\r\n            this.waterGroup.position.x = offsetX;\r\n            this.waterGroup.position.z = offsetY;\r\n        }\r\n\r\n        if (this.lastCubeCenter.x == offsetX && this.lastCubeCenter.y == offsetY)\r\n            return;\r\n\r\n        if (Math.abs(offsetX - this.lastGrassCenter.x) > 3 || Math.abs(offsetY - this.lastGrassCenter.y) > 3) {\r\n            this.workerPool.getWorker().postMessage([\"grass\", offsetX, offsetY, gameModel.settings.detailSettings.grassDensity,\r\n                gameModel.settings.detailSettings.grassNumber]);\r\n            this.workerPool.getWorker().postMessage([\"tree\", offsetX, offsetY, gameModel.settings.detailSettings.treeNumber]);\r\n            this.lastGrassCenter.x = offsetX;\r\n            this.lastGrassCenter.y = offsetY;\r\n        }\r\n\r\n        let centerChunk = {\r\n            x: Math.round(offsetX / this.chunkSize) * this.chunkSize,\r\n            y: Math.round(offsetY / this.chunkSize) * this.chunkSize,\r\n        }\r\n        var minX = centerChunk.x - (this.chunkRange * this.chunkSize);\r\n        var maxX = centerChunk.x + (this.chunkRange * this.chunkSize);\r\n        var minY = centerChunk.y - (this.chunkRange * this.chunkSize);\r\n        let maxY = centerChunk.y + (this.chunkRange * this.chunkSize);\r\n        for (var i = 0; i < this.chunks.length; i++) {\r\n            if (this.chunks[i].x < minX || this.chunks[i].x > maxX || this.chunks[i].y < minY || this.chunks[i].y > maxY) {\r\n                this.destroyChunk(this.chunks[i]);\r\n                this.chunks.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n        if (!this.called && this.chunkMap[centerChunk.x] && this.chunkMap[centerChunk.x][centerChunk.y]) {\r\n            this.called = true;\r\n            this.callback();\r\n        }\r\n        for (var i = -this.chunkRange; i <= this.chunkRange; i++) {\r\n            var x = centerChunk.x + (i * this.chunkSize);\r\n            for (var j = -this.chunkRange; j <= this.chunkRange; j++) {\r\n                var y = centerChunk.y + (j * this.chunkSize);\r\n                if (!this.chunkMap[x] || !this.chunkMap[x][y]) {\r\n                    this.createChunk2(x, y);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.lastCubeCenter.x = offsetX;\r\n        this.lastCubeCenter.y = offsetY;\r\n    }\r\n}","export const MyShaders = {\r\n\r\n  TreeVertexShader: `\r\n          #define MYGRASS\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n\r\n          varying vec3 vUv;\r\n          uniform float time;\r\n          uniform float amp;\r\n          uniform float maxDistance;\r\n          varying float fade;\r\n\r\n          void main() {\r\n\r\n              vUv = position;\r\n      \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              \r\n              vec4 mvPosition = vec4( transformed, 1.0 );\r\n              if (position.y > 1.0) {\r\n                float freq = 0.01;\r\n                float angle = time * freq;\r\n                angle += instanceMatrix[3].x;\r\n                mvPosition.z += cos(angle) * amp * position.y;\r\n              }\r\n\r\n              #ifdef USE_INSTANCING\r\n                mvPosition = instanceMatrix * mvPosition;\r\n              #endif\r\n\r\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\r\n\r\n              mvPosition = modelViewMatrix * mvPosition;              \r\n              gl_Position = projectionMatrix * mvPosition;\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n\r\n              fade = 1.0;             \r\n\r\n              if (dist > maxDistance * 0.9) {\r\n                if (dist > maxDistance) {\r\n                  fade = 0.0;\r\n                } else {\r\n                  fade = ((maxDistance - dist) / (maxDistance * 0.1));\r\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\r\n                }\r\n              }\r\n\r\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\t            // gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  TreeFragmentShader: `\r\n      uniform vec3 diffuse;\r\n      uniform vec3 emissive;\r\n      uniform float opacity;\r\n      varying vec3 vLightFront;\r\n      varying vec3 vIndirectFront;\r\n      #ifdef DOUBLE_SIDED\r\n          varying vec3 vLightBack;\r\n          varying vec3 vIndirectBack;\r\n      #endif\r\n      #include <common>\r\n      #include <packing>\r\n      #include <dithering_pars_fragment>\r\n      #include <color_pars_fragment>\r\n      #include <uv_pars_fragment>\r\n      #include <uv2_pars_fragment>\r\n      #include <map_pars_fragment>\r\n      #include <alphamap_pars_fragment>\r\n      #include <aomap_pars_fragment>\r\n      #include <lightmap_pars_fragment>\r\n      #include <emissivemap_pars_fragment>\r\n      #include <envmap_common_pars_fragment>\r\n      #include <envmap_pars_fragment>\r\n      #include <cube_uv_reflection_fragment>\r\n      #include <bsdfs>\r\n      #include <lights_pars_begin>\r\n      #include <fog_pars_fragment>\r\n      #include <shadowmap_pars_fragment>\r\n      #include <shadowmask_pars_fragment>\r\n      #include <specularmap_pars_fragment>\r\n      #include <logdepthbuf_pars_fragment>\r\n      #include <clipping_planes_pars_fragment>\r\n\r\n      varying vec3 vUv;\r\n      varying float fade;\r\n      \r\n      void main() {\r\n          #include <clipping_planes_fragment>\r\n\r\n          vec4 diffuseColor = vec4( diffuse, opacity );\r\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n          vec3 totalEmissiveRadiance = emissive;\r\n          #include <logdepthbuf_fragment>\r\n          #include <map_fragment>\r\n          #include <color_fragment>\r\n          #include <alphamap_fragment>\r\n          #include <alphatest_fragment>\r\n          #include <specularmap_fragment>\r\n          #include <emissivemap_fragment>\r\n          reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n          #ifdef DOUBLE_SIDED\r\n              reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n          #else\r\n              reflectedLight.indirectDiffuse += vIndirectFront;\r\n          #endif\r\n          #include <lightmap_fragment>\r\n          reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n          #ifdef DOUBLE_SIDED\r\n              reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n          #else\r\n              reflectedLight.directDiffuse = vLightFront;\r\n          #endif\r\n          reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n          #include <aomap_fragment>\r\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n          #include <envmap_fragment>\r\n          if (fade < 1.0) {\r\n            diffuseColor.a = fade;\r\n          }\r\n          gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n          #include <tonemapping_fragment>\r\n          #include <encodings_fragment>\r\n          #include <fog_fragment>\r\n          #include <premultiplied_alpha_fragment>\r\n          #include <dithering_fragment>\r\n      }\r\n    `,\r\n\r\n  GrassVertexShader: `\r\n          #define MYGRASS\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n\r\n          varying vec3 vUv;\r\n          attribute float tex;\r\n          varying float texFloat;\r\n          uniform float time;\r\n          uniform float amp;\r\n          uniform float maxDistance;\r\n          varying float fade;\r\n\r\n          void main() {\r\n\r\n              vUv = position;\r\n              texFloat = tex;\r\n      \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              \r\n              vec4 mvPosition = vec4( transformed, 1.0 );\r\n              if (position.y > 0.0) {\r\n                float freq = 0.2 * min(max(instanceMatrix[0].x, 0.7), 1.8);\r\n                float angle = ((time * 0.2) + (position.y * 8.0)) * freq;\r\n                angle += instanceMatrix[3].x;\r\n                mvPosition.z += cos(angle) * amp * freq;\r\n              }\r\n\r\n              #ifdef USE_INSTANCING\r\n                mvPosition = instanceMatrix * mvPosition;\r\n              #endif\r\n\r\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\r\n\r\n              mvPosition = modelViewMatrix * mvPosition;              \r\n              gl_Position = projectionMatrix * mvPosition;\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n\r\n              fade = 1.0;             \r\n\r\n              if (dist > maxDistance * 0.5) {\r\n                if (dist > maxDistance) {\r\n                  fade = 0.0;\r\n                } else {\r\n                  fade = ((maxDistance - dist) / (maxDistance * 0.5));\r\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\r\n                }\r\n              }\r\n\r\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\t            // gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  GrassFragmentShader: `\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform float opacity;\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <fog_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <shadowmask_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n  \r\n          uniform sampler2D texture1;\r\n          uniform sampler2D texture2;\r\n          uniform sampler2D texture3;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n          varying float fade;\r\n          \r\n          void main() {\r\n              #include <clipping_planes_fragment>\r\n  \r\n              vec4 diffuseColor = vec4(0.0,0.0,0.0,0.0);\r\n\r\n              if (texFloat < 0.3) {\r\n                diffuseColor = texture2D(texture1, 1.6 * vUv.xy + vec2(.51, .51));\r\n              } else if (texFloat > 0.7) {\r\n                diffuseColor = texture2D(texture2, 1.8 * vUv.xy + vec2(.51, .51));\r\n              } else {\r\n                diffuseColor = texture2D(texture3, 1.8 * vUv.xy + vec2(.53, .51));\r\n              }\r\n  \r\n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n              vec3 totalEmissiveRadiance = emissive;\r\n              #include <logdepthbuf_fragment>\r\n              #include <map_fragment>\r\n              #include <color_fragment>\r\n              #include <alphamap_fragment>\r\n              #include <alphatest_fragment>\r\n              #include <specularmap_fragment>\r\n              #include <emissivemap_fragment>\r\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n              #else\r\n                  reflectedLight.indirectDiffuse += vIndirectFront;\r\n              #endif\r\n              #include <lightmap_fragment>\r\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n              #else\r\n                  reflectedLight.directDiffuse = vLightFront;\r\n              #endif\r\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n              #include <aomap_fragment>\r\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n              #include <envmap_fragment>\r\n              if (fade < 1.0) {\r\n                diffuseColor.a = fade;\r\n              }\r\n              gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n              #include <tonemapping_fragment>\r\n              #include <encodings_fragment>\r\n              #include <fog_fragment>\r\n              #include <premultiplied_alpha_fragment>\r\n              #include <dithering_fragment>\r\n          }\r\n      `,\r\n\r\n  LandVertexShader: `\r\n          #define MYLAND\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n          attribute float tex;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n          void main() {\r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              #include <project_vertex>\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n  \r\n              vUv = position;\r\n              texFloat = tex;\r\n          }\r\n      `,\r\n\r\n  LandFragmentShader: `\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform float opacity;\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <fog_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <shadowmask_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n\r\n          uniform sampler2D grassTexture;\r\n          uniform sampler2D sandTexture;\r\n          uniform sampler2D gravelTexture;\r\n          uniform sampler2D snowTexture;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n  \r\n          void main() {\r\n              #include <clipping_planes_fragment>\r\n\r\n              vec4 color = vec4(0.0,0.0,0.0,0.0);\r\n              float tScale = 1.0;\r\n\r\n              if (texFloat > 0.0 && texFloat <= 1.0) {\r\n                color = mix(color, texture2D(sandTexture, vUv.xz * tScale), texFloat);\r\n              }\r\n              if (texFloat > 1.0 && texFloat <= 2.0) {\r\n                color = texture2D(sandTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(grassTexture, vUv.xz * tScale), texFloat - 1.0);\r\n              }\r\n              if (texFloat > 2.0 && texFloat <= 3.0) {\r\n                color = texture2D(grassTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(gravelTexture, vUv.xz * tScale), texFloat - 2.0);\r\n              }\r\n              if (texFloat > 3.0 && texFloat <= 4.0) {\r\n                color = texture2D(gravelTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(snowTexture, vUv.xz * tScale), texFloat - 3.0);\r\n              }\r\n  \r\n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n              vec3 totalEmissiveRadiance = emissive;\r\n              #include <logdepthbuf_fragment>\r\n              #include <map_fragment>\r\n              #include <color_fragment>\r\n              #include <alphamap_fragment>\r\n              #include <alphatest_fragment>\r\n              #include <specularmap_fragment>\r\n              #include <emissivemap_fragment>\r\n              //reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n              #else\r\n                  reflectedLight.indirectDiffuse += vIndirectFront;\r\n              #endif\r\n              #include <lightmap_fragment>\r\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( color.rgb );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n              #else\r\n                  reflectedLight.directDiffuse = vLightFront;\r\n              #endif\r\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( color.rgb ) * getShadowMask();\r\n              #include <aomap_fragment>\r\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n              #include <envmap_fragment>\r\n              gl_FragColor = vec4( outgoingLight, color.a );\r\n              #include <tonemapping_fragment>\r\n              #include <encodings_fragment>\r\n              #include <fog_fragment>\r\n              #include <premultiplied_alpha_fragment>\r\n              #include <dithering_fragment>\r\n          }\r\n      `,\r\n\r\n  WaterVertexShader: `\r\n          #define MYWATER\r\n          varying vec3 vViewPosition;\r\n          #ifndef FLAT_SHADED\r\n              varying vec3 vNormal;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <displacementmap_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n  \r\n          varying vec3 vUv;\r\n          uniform float time;\r\n          uniform float amp;\r\n  \r\n          void main() {\r\n              vUv = position; \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n          #ifndef FLAT_SHADED\r\n              vNormal = normalize( transformedNormal );\r\n          #endif\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              #include <displacementmap_vertex>\r\n              #include <project_vertex>\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              vViewPosition = - mvPosition.xyz;\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n  \r\n            vNormal = normalMatrix * normal;\r\n            //float freq = 0.3;\r\n            //float angle = ((time * 0.2) + (position.x * 8.0))*freq;\r\n            //vUv.z += sin(angle)*amp;\r\n            //vNormal = normalMatrix * normalize(vec3(-amp * freq * cos(angle),0.0,1.0));\r\n            vec4 modelViewPosition = modelViewMatrix * vec4(vUv, 1.0);\r\n            gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  WaterFragmentShader: `\r\n          #define MYWATER\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform vec3 specular;\r\n          uniform float shininess;\r\n          uniform float opacity;\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <fog_pars_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <lights_phong_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <bumpmap_pars_fragment>\r\n          #include <normalmap_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n  \r\n          varying vec3 vPos;\r\n          uniform float time;\r\n          uniform sampler2D texture1;\r\n              varying vec3 vUv;\r\n\r\n          float noise(vec2 n) {\r\n              const vec2 d = vec2(0.0, 1.0);\r\n                vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\n              return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n          }\r\n          \r\n          void main() {\r\n            #include <clipping_planes_fragment>\r\n            // compute moving color            \r\n  \r\n            // Compute the ripple effect.\r\n            float mod1 = 16.0;\r\n            float mod2 = 0.4;\r\n            float xoffset = 0.05 * cos(time / 52.0 + mod1 * vUv.y) + 0.09 * cos(time / 65.0 + mod2 * vUv.y);\r\n            float time2 = time + 0.8;\r\n            float yoffset = 0.02 * cos(time2 / 35.0 + mod1 * vUv.x) + 0.07 * cos(time2 / 55.0 + mod2 * vUv.x);\r\n            vec4 diffuseColor = texture2D(texture1, vec2((vUv.x + xoffset) * 0.25, (vUv.y + yoffset) * 0.25));\r\n            // vec4 diffuseColor = texture2D(texture1, vUv.xy + (time  * 0.001));\r\n            \r\n            //vec4 diffuseColor = vec4( diffuse, opacity );\r\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n            vec3 totalEmissiveRadiance = emissive;\r\n            #include <logdepthbuf_fragment>\r\n            #include <map_fragment>\r\n            #include <color_fragment>\r\n            #include <alphamap_fragment>\r\n            #include <alphatest_fragment>\r\n            #include <specularmap_fragment>\r\n            #include <normal_fragment_begin>\r\n            float nr = noise(vec2(vUv.x + (time * 0.01) + 2.0, vUv.y) * 3.0) - 0.5;\r\n            float nr2 = noise(vec2(vUv.x, vUv.y + (time * 0.01)) * 3.5) - 0.5;\r\n            float res = mix(nr, nr2, 0.5);\r\n            // normal.z = normal.z - 0.1 + (nr * 0.1 * cos((time + (vUv.x + vUv.y) * 10.0)/ 25.0));\r\n            if (res > 0.0) {\r\n              normal.z = normal.z - 0.1 + res * 0.2;\r\n            } else {\r\n              normal.z = normal.z - 0.1;\r\n            }\r\n\r\n            #include <normal_fragment_maps>\r\n            #include <emissivemap_fragment> \r\n            #include <lights_phong_fragment>\r\n            #include <lights_fragment_begin>\r\n            #include <lights_fragment_maps>\r\n            #include <lights_fragment_end>\r\n            #include <aomap_fragment>\r\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n            #include <envmap_fragment>\r\n            gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n            #include <tonemapping_fragment>\r\n            #include <encodings_fragment>\r\n            #include <fog_fragment>\r\n            #include <premultiplied_alpha_fragment>\r\n            #include <dithering_fragment>\r\n            gl_FragColor.a = 0.9;\r\n          }\r\n      `\r\n}","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"terrain-worker.js\");\n};","// three.js\r\nimport * as THREE from 'three';\r\n\r\nexport class MyCamera {\r\n\r\n    public camera : THREE.PerspectiveCamera;\r\n\r\n    constructor(scene : THREE.Scene) {\r\n        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);\r\n        // this.camera.rotation.y = Math.PI;\r\n        this.camera.position.x = 96;\r\n        this.camera.position.y = -100000;\r\n        this.camera.position.z = 33;\r\n        scene.add(this.camera);\r\n    }\r\n    \r\n}","import { MyCamera } from \"./camera\";\r\nimport { Vehicle, Walking } from \"./vehicles\";\r\n\r\nexport class Controls {\r\n\r\n\tpublic flashLight : boolean = true;\r\n\r\n\tpublic camera : MyCamera\r\n\tpublic currentVehicle : Vehicle\r\n\tpublic lastVehicle : Vehicle\r\n\tpublic vehicleWalking : Walking\r\n\r\n\tpublic handleMovement(timeDiff : number) {\r\n\t\tthis.currentVehicle.handleMovement(timeDiff);\r\n\t}\r\n    \r\n    constructor(myCamera : MyCamera) {\r\n\t\tthis.camera = myCamera;\r\n\t\tthis.vehicleWalking = new Walking(this.camera.camera, this);\r\n\t\tthis.currentVehicle = this.vehicleWalking;\r\n    }\r\n}","import { Controls } from \"./controls\";\r\nimport { getHeight } from \"../terrain/utils\";\r\nimport { isWater } from \"../terrain/terrain\";\r\n\r\nexport class Vehicle {\r\n    speed : THREE.Vector2;\r\n    acceleration : number;\r\n    drag : number;\r\n    turnSpeed : number;\r\n    preferredZoom : number;\r\n    camera : THREE.PerspectiveCamera;\r\n    controls : Controls;\r\n    handleMovement(timeDiff : number) : void {\r\n\r\n    }\r\n    onInit() : void {\r\n\r\n    }\r\n    onDestroy() : void {\r\n\r\n    }\r\n}\r\n\r\nexport class Walking extends Vehicle {\r\n    speed : THREE.Vector2 = new THREE.Vector2(0,4);\r\n    preferredZoom: number = 12;\r\n    constructor(camera : THREE.PerspectiveCamera, controls : Controls) {\r\n        super();\r\n        this.camera = camera;\r\n        this.controls = controls;\r\n    }\r\n    handleMovement(timeDiff: number): void {\r\n\r\n        this.camera.rotation.x = -0.7;\r\n\r\n        this.camera.position.x += this.speed.x * timeDiff;\r\n        this.camera.position.z -= this.speed.y * timeDiff;\r\n\r\n        let height = getHeight(this.camera.position.x, this.camera.position.z);\r\n        \r\n        var diff = (height + this.preferredZoom) - this.camera.position.y;\r\n        if (Math.abs(diff) > 30) {\r\n            this.camera.position.y = (height + this.preferredZoom);\r\n        } else {\r\n            this.camera.position.y += diff * timeDiff * 2;\r\n        }\r\n    }\r\n}"],"sourceRoot":""}