{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"THREE\"","webpack:///./src/ts/terrain/constants.ts","webpack:///./src/ts/terrain/utils.ts","webpack:///./src/ts/game/gamemodel.ts","webpack:///./src/index.ts","webpack:///./src/ts/terrain/terrain.ts","webpack:///./src/ts/shaders.ts","webpack:///./src/ts/terrain/terrain.worker.ts","webpack:///./src/ts/game/camera.ts","webpack:///./src/ts/game/controls.ts","webpack:///./src/ts/game/vehicles.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","heights","water","sand","plainsMin","plainsMax","mountainFactor","mountainMod","chunkSize","x","y","chunkRange","noiseSeed","maximumTrees","maximumGrass","heightAdjustment","height","noise","simplex2","plainsHeight","Math","pow","max","snowMod","gravelMod","greenColor","Color","brownColor","geo","Geometry","level1","ConeGeometry","faces","forEach","f","color","set","translate","merge","level2","level3","trunk","CylinderGeometry","bufferGeo","BufferGeometry","fromGeometry","model","settings","terrainSettings","settingsChanged","Constants","detailSettings","treeNumber","grassNumber","grassDensity","rendererSettings","antialias","resolution","seedSettings","seed","startApplication","gameModel","getGameModel","scene","Scene","terrain","Terrain","camera","Camera","MyCamera","controls","Controls","renderer","WebGLRenderer","setSize","window","innerWidth","innerHeight","background","document","body","appendChild","domElement","sunGroup","Group","add","sunLightColor","dirLight","DirectionalLight","position","z","target","currTime","lastTime","animate","requestAnimationFrame","console","log","setPixelRatio","Date","now","timeDiff","min","updateChunks","handleMovement","render","onresize","aspect","updateProjectionMatrix","grassTexture","TextureLoader","load","grassBladeTexture","grassBladeTexture2","grassBladeTexture3","gravelTexture","sandTexture","waterTexture","snowTexture","wrapS","MirroredRepeatWrapping","wrapT","RepeatWrapping","magFilter","NearestFilter","uniforms","UniformsUtils","ShaderLib","phong","texture1","type","time","amp","waterMaterial","ShaderMaterial","vertexShader","MyShaders","WaterVertexShader","fragmentShader","WaterFragmentShader","lights","transparent","alphaTest","landUniforms","standard","grassUniforms","lambert","texture2","texture3","maxDistance","treeUniforms","getGrassMesh","PlaneBufferGeometry","InstancedMesh","side","DoubleSide","GrassVertexShader","GrassFragmentShader","getTreeMesh","getTreeGeometery","vertexColors","TreeVertexShader","TreeFragmentShader","landMaterial","LandVertexShader","LandFragmentShader","BackSide","waterGeometry","waterPlane","Mesh","rotation","PI","staticWaterGeo","staticWater","MeshPhongMaterial","map","WorkerPool","maxWorkers","onMessage","workers","counter","this","length","worker","onmessage","push","Chunk","size","planeMesh","discarded","chunks","chunkMap","discardedChunks","maxTreeDistance","maxGrassDistance","lastCubeCenter","lastGrassCenter","group","waterGroup","terrainGroup","grassMesh","treeMesh","that","workerPool","event","data","processGrass","grassMatrices","grassTextures","processTrees","treeMatrices","processChunk","pa","landTextures","chunk","pop","processed","computeBoundingSphere","computeVertexNormals","foreignChunk","foreignNormals","foreignIndex","hVerts","wVerts","normals","getAttribute","setXYZ","getX","getY","getZ","needsUpdate","grassTextureArray","Float32Array","count","instanceMatrix","copyArray","geometry","setAttribute","InstancedBufferAttribute","treeMatrixArray","paData","visible","BufferAttribute","fixChunkNormals","createChunkObject","getWorker","postMessage","keys","dispose","remove","destroyAllChunks","isNaN","updateSettings","updateDetailSettings","updateUniforms","offsetX","round","offsetY","abs","centerChunk","minX","maxX","minY","maxY","destroyChunk","splice","j","createChunk2","Worker","PerspectiveCamera","myCamera","flashLight","vehicleWalking","Walking","currentVehicle","Vehicle","super","speed","Vector2","preferredZoom","diff","getHeight"],"mappings":"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","file":"terrain.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = THREE;","export const heights = {\r\n    water: 4.3,\r\n    sand: 5.0,\r\n    plainsMin: 4,\r\n    plainsMax: 35,\r\n    mountainFactor : 1.6\r\n}\r\nexport const mountainMod = heights.plainsMax - (heights.plainsMin + ((heights.plainsMax - heights.plainsMin) / 4));\r\nexport const chunkSize = { x: 128, y: 128 };\r\nexport const chunkRange = 3;\r\nexport const noiseSeed = 1024;\r\nexport const maximumTrees = 500;\r\nexport const maximumGrass = 2000;","import {heights, mountainMod} from './constants';\r\n\r\nconst heightAdjustment = heights.plainsMin + ((heights.plainsMax - heights.plainsMin) / 4);\r\n\r\nexport function getHeight(x : number, y : number) {\r\n    let height =\r\n        0.5 * noise.simplex2(x / 8,   y / 8) +\r\n        2   * noise.simplex2(x / 32,  y / 32) +\r\n        10  * noise.simplex2(x / 100, y / 100) +\r\n        32  * noise.simplex2(x / 200, y / 200) +\r\n        32  * noise.simplex2(x / 500, y / 500) +\r\n        24  * noise.simplex2(x / 900, y / 900);\r\n\r\n    height += 30;\r\n        \r\n    let plainsHeight = heights.plainsMin + ((height - heights.plainsMin) / 4);\r\n\r\n    if (height > heights.plainsMax) {\r\n        return Math.pow(plainsHeight - heightAdjustment, heights.mountainFactor) + heightAdjustment;\r\n    }\r\n    return plainsHeight;\r\n}\r\n\r\nexport function getLandTexture(x : number, y : number, height : number) {\r\n\r\n    if (height < heights.water - 1) {\r\n        return 0 + Math.max(height - (heights.water - 2), 0);\r\n        // return 0;\r\n    }\r\n    if (height < heights.sand + 0.5){\r\n        return 1;\r\n    }\r\n    if (height < heights.sand + 1.0)\r\n        return 1 + 2 * (height - (heights.sand + 0.5));\r\n    let snowMod = 3 + (3 * noise.simplex2(x / 20, y / 20));\r\n    if (height > heights.plainsMax + 5 + snowMod)\r\n        return 4;\r\n    if (height > heights.plainsMax + 3.0 + snowMod)\r\n        return 3 + ((height - (heights.plainsMax + 3.0 + snowMod)) * 0.5);\r\n    let gravelMod = 5 + (5 * noise.simplex2(x / 15, y / 15));\r\n    if (height > mountainMod + gravelMod)\r\n        return 3;\r\n    if (height > mountainMod + gravelMod - 2) {\r\n        return 2 + ((height - (mountainMod + gravelMod - 2)) * 0.5);\r\n    }\r\n    return 2;\r\n}\r\n\r\nexport function getTreeGeometery() : THREE.BufferGeometry {\r\n    const greenColor = new THREE.Color(0x317830);\r\n    const brownColor = new THREE.Color(0x6e3626);\r\n    const geo = new THREE.Geometry();\r\n    const level1 = new THREE.ConeGeometry(0.8,1.6,10);\r\n    level1.faces.forEach(f => f.color.set(greenColor));\r\n    level1.translate(0,3.7,0);\r\n    geo.merge(level1);\r\n    const level2 = new THREE.ConeGeometry(1.0,1.8,10);\r\n    level2.faces.forEach(f => f.color.set(greenColor));\r\n    level2.translate(0,2.9,0);\r\n    geo.merge(level2);\r\n    const level3 = new THREE.ConeGeometry(1.2,2,10);\r\n    level3.faces.forEach(f => f.color.set(greenColor));\r\n    level3.translate(0,2,0);\r\n    geo.merge(level3);\r\n    const trunk = new THREE.CylinderGeometry(0.3,0.3,2);\r\n    trunk.translate(0, -0.0, 0);\r\n    trunk.faces.forEach(f => f.color.set(brownColor));\r\n    geo.merge(trunk);\r\n    let bufferGeo = new THREE.BufferGeometry();\r\n    bufferGeo.fromGeometry(geo);\r\n    return bufferGeo;\r\n}\r\n\r\n// export function isWater(height : number) : boolean {\r\n//     return height < heights.water + 0.55;\r\n// }","import * as Constants from '../terrain/constants';\r\n\r\nclass GameModel {\r\n\r\n    public settings = {\r\n        terrainSettings : {\r\n            settingsChanged : false,\r\n            chunkSize : Constants.chunkSize.x,\r\n            chunkRange : 5\r\n        },\r\n        detailSettings : {\r\n            settingsChanged : false,\r\n            treeNumber : 1000,\r\n            grassNumber : 20000,\r\n            grassDensity : 0.25\r\n        },\r\n        rendererSettings : {\r\n            settingsChanged : false,\r\n            antialias : false,\r\n            resolution : 1.0\r\n        },\r\n        seedSettings : {\r\n            seed : Constants.noiseSeed,\r\n            settingsChanged : false\r\n        }\r\n    }\r\n}\r\n\r\nconst model = new GameModel();\r\n\r\nexport function getGameModel() : GameModel {\r\n    return model;\r\n}","// three.js\r\nimport * as THREE from 'three';\r\nimport * as Terrain from './ts/terrain/terrain';\r\nimport * as Camera from './ts/game/camera';\r\nimport { Controls } from './ts/game/controls';\r\nimport { getGameModel } from './ts/game/gamemodel';\r\n\r\nexport function startApplication() {\r\n  const gameModel = getGameModel();\r\n\r\n  // create the scene\r\n  const scene = new THREE.Scene();\r\n  let terrain = new Terrain.Terrain(scene);\r\n\r\n  // create the camera and controls\r\n  const camera = new Camera.MyCamera(scene);\r\n  const controls = new Controls(camera);\r\n  const renderer = new THREE.WebGLRenderer({ antialias: false });\r\n\r\n  // set size\r\n  renderer.setSize(window.innerWidth, window.innerHeight);\r\n  scene.background = new THREE.Color(0, 0, 0);\r\n\r\n  // add canvas to dom\r\n  document.body.appendChild(renderer.domElement);\r\n\r\n  // setup lights\r\n\r\n  let sunGroup = new THREE.Group();\r\n  scene.add(sunGroup);\r\n\r\n  const sunMax = 0.6;\r\n  const sunLightColor = new THREE.Color(0xFFFFDD);\r\n  let dirLight = new THREE.DirectionalLight(sunLightColor, sunMax);\r\n  dirLight.position.y = 3000;\r\n  dirLight.position.z = 1000;\r\n  dirLight.target = camera.camera;\r\n  sunGroup.add(dirLight);\r\n\r\n  function animate(): void {\r\n    requestAnimationFrame(animate);\r\n    render();\r\n  }\r\n\r\n  let currTime = 0, lastTime = 0;\r\n\r\n  function render(): void {\r\n\r\n    if (gameModel.settings.rendererSettings.settingsChanged) {\r\n      console.log(\"render settings changed\");\r\n      renderer.setPixelRatio(gameModel.settings.rendererSettings.resolution);\r\n      gameModel.settings.rendererSettings.settingsChanged = false;\r\n    }\r\n\r\n    currTime = Date.now();\r\n    let timeDiff = Math.min((currTime - lastTime) / 1000, 1);\r\n    lastTime = currTime;\r\n    terrain.updateChunks(timeDiff, camera.camera);\r\n    controls.handleMovement(timeDiff);\r\n    renderer.render(scene, camera.camera);\r\n  }\r\n\r\n  animate();\r\n\r\n  window.onresize = function () {\r\n    camera.camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.camera.updateProjectionMatrix();\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n  };\r\n\r\n}\r\n\r\nstartApplication();","// three.js\r\nimport * as THREE from 'three';\r\nimport {MyShaders} from \"../shaders\";\r\nimport MyWorker from './terrain.worker';\r\nimport {heights, noiseSeed, maximumGrass, maximumTrees} from './constants';\r\nimport {getTreeGeometery} from './utils';\r\nimport { getGameModel } from '../game/gamemodel';\r\n\r\nconst gameModel = getGameModel();\r\nnoise.seed(gameModel.settings.seedSettings.seed);\r\nconst grassTexture = new THREE.TextureLoader().load('img/grass.png');\r\nconst grassBladeTexture = new THREE.TextureLoader().load('img/grassblade.png');\r\nconst grassBladeTexture2 = new THREE.TextureLoader().load('img/grassblade2.png');\r\nconst grassBladeTexture3 = new THREE.TextureLoader().load('img/grassblade3.png');\r\nconst gravelTexture = new THREE.TextureLoader().load('img/gravel.png');\r\nconst sandTexture = new THREE.TextureLoader().load('img/sand.png');\r\nconst waterTexture = new THREE.TextureLoader().load('img/water.jpg');\r\nconst snowTexture = new THREE.TextureLoader().load('img/snow.png');\r\nwaterTexture.wrapS = THREE.MirroredRepeatWrapping;\r\nwaterTexture.wrapT = THREE.MirroredRepeatWrapping;\r\nwaterTexture.wrapT = THREE.RepeatWrapping;\r\ngravelTexture.wrapS = snowTexture.wrapS = sandTexture.wrapS = grassTexture.wrapS = THREE.RepeatWrapping;\r\ngravelTexture.wrapT = snowTexture.wrapT = sandTexture.wrapT = grassTexture.wrapT = THREE.RepeatWrapping;\r\ngravelTexture.magFilter = snowTexture.magFilter = sandTexture.magFilter = grassTexture.magFilter = THREE.NearestFilter;\r\n\r\nconst uniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.phong.uniforms]);\r\nuniforms.texture1 = { type: \"t\", value: waterTexture };\r\nuniforms.time = { type: \"f\", value: 1.0 };\r\nuniforms.amp = { type: \"f\", value: 0.004 };\r\n\r\nconst waterMaterial = new THREE.ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: MyShaders.WaterVertexShader,\r\n    fragmentShader: MyShaders.WaterFragmentShader,\r\n    lights: true, transparent : true, alphaTest : 0.5,\r\n});\r\n\r\n// const waterMaterial = new THREE.MeshPhongMaterial({map:waterTexture, bumpMap:waterTexture, bumpScale:0.1, transparent:true, alphaTest:0.5});\r\n\r\nconst landUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.standard.uniforms]);\r\nlandUniforms.grassTexture = { type: \"t\", value: grassTexture };\r\nlandUniforms.sandTexture = { type: \"t\", value: sandTexture };\r\nlandUniforms.snowTexture = { type: \"t\", value: snowTexture };\r\nlandUniforms.gravelTexture = { type: \"t\", value: gravelTexture };\r\n\r\nconst grassUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.lambert.uniforms]);\r\ngrassUniforms.texture1 = { type: \"t\", value: grassBladeTexture };\r\ngrassUniforms.texture2 = { type: \"t\", value: grassBladeTexture2 };\r\ngrassUniforms.texture3 = { type: \"t\", value: grassBladeTexture3 };\r\ngrassUniforms.time = { type: \"f\", value: 0 };\r\ngrassUniforms.amp = { type: \"f\", value: 0.5 };\r\ngrassUniforms.maxDistance = { type : \"f\", value : 30};\r\n\r\nconst treeUniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.lambert.uniforms]);\r\ntreeUniforms.time = { type: \"f\", value: 0 };\r\ntreeUniforms.amp = { type: \"f\", value: 0.05 };\r\ntreeUniforms.maxDistance = { type : \"f\", value : 30};\r\n\r\nfunction getGrassMesh() : THREE.InstancedMesh {\r\n    let geo = new THREE.PlaneBufferGeometry(0.5, 0.5);\r\n    // geo.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array([0,1,0.7,0,1,0.7, // top\r\n    //                                                                         0,0.7,1,0,0.7,1]), // bottom\r\n    //                                                                         3, false));\r\n    \r\n    return new THREE.InstancedMesh( geo, \r\n        new THREE.ShaderMaterial({ \r\n            uniforms : grassUniforms, \r\n            side : THREE.DoubleSide, \r\n            vertexShader : MyShaders.GrassVertexShader,\r\n            fragmentShader : MyShaders.GrassFragmentShader,\r\n            transparent : true, alphaTest : 0.5, \r\n            lights : true\r\n        }), \r\n        // new THREE.MeshBasicMaterial(),\r\n        gameModel.settings.detailSettings.grassNumber);\r\n}\r\n\r\nfunction getTreeMesh() : THREE.InstancedMesh {\r\n    return new THREE.InstancedMesh( getTreeGeometery(), \r\n        new THREE.ShaderMaterial({\r\n            uniforms : treeUniforms,\r\n            vertexColors: true, \r\n            vertexShader : MyShaders.TreeVertexShader,\r\n            fragmentShader : MyShaders.TreeFragmentShader,\r\n            lights : true, transparent : true, alphaTest : 0.5,\r\n        }),\r\n        gameModel.settings.detailSettings.treeNumber);\r\n}\r\n\r\nlet landMaterial = new THREE.ShaderMaterial({\r\n    uniforms: landUniforms,\r\n    vertexShader: MyShaders.LandVertexShader,\r\n    // vertexShader : THREE.ShaderLib.lambert.vertexShader,\r\n    fragmentShader: MyShaders.LandFragmentShader,\r\n    // fragmentShader : THREE.ShaderLib.lambert.fragmentShader,\r\n    lights: true, side : THREE.BackSide\r\n    // fog: true\r\n});\r\n\r\n// new THREE.MeshLambertMaterial({side : THREE.BackSide});\r\n\r\n// var waterGeometry = new THREE.PlaneBufferGeometry(320, 320, 480, 1);\r\nvar waterGeometry = new THREE.PlaneBufferGeometry(4000, 4000, 1, 1);\r\nvar waterPlane = new THREE.Mesh(waterGeometry, waterMaterial);\r\nwaterPlane.position.y = heights.water + 0.55;\r\nwaterPlane.rotation.x = -0.5 * Math.PI;\r\nvar staticWaterGeo = new THREE.PlaneBufferGeometry(6400, 6400, 1, 1);\r\nvar staticWater = new THREE.Mesh(staticWaterGeo, new THREE.MeshPhongMaterial({ map: waterTexture }));\r\nstaticWater.position.y = heights.water + 0.5;\r\nstaticWater.rotation.x = -0.5 * Math.PI;\r\n\r\nexport function isWater(height : number) : boolean {\r\n    return height < waterPlane.position.y;\r\n}\r\n\r\nclass WorkerPool {\r\n    private workers : Worker[] = [];\r\n    private counter : number = 0;\r\n    private maxWorkers : number = 1;\r\n    private onMessage : (event : MessageEvent) => void;\r\n    constructor(maxWorkers : number, onMessage :  (event : MessageEvent) => void) {\r\n        this.maxWorkers = maxWorkers;\r\n        this.onMessage = onMessage;\r\n    }\r\n    public getWorker() : Worker {\r\n        if (this.workers.length < this.maxWorkers) {\r\n            let worker = new MyWorker();\r\n            worker.onmessage = this.onMessage;\r\n            this.workers.push(worker);\r\n        }\r\n        this.counter++;\r\n        if (this.counter > this.workers.length - 1) {\r\n            this.counter = 0;\r\n        }\r\n        return this.workers[this.counter];        \r\n    }\r\n}\r\n\r\nclass Chunk {\r\n    public x : number;\r\n    public y : number;\r\n    public geo: THREE.PlaneBufferGeometry;\r\n    public planeMesh : THREE.Mesh;\r\n    public discarded : boolean;\r\n    public processed : boolean;\r\n    constructor(x : number, y : number, size : number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.geo = new THREE.PlaneBufferGeometry(size, size, size, size);\r\n        this.planeMesh = new THREE.Mesh(this.geo, landMaterial);\r\n        this.discarded = false;\r\n    }\r\n}\r\n\r\nexport class Terrain {\r\n\r\n    public chunkRange : number = 1;\r\n    public chunkSize : number = 32;\r\n    private chunks : Chunk[] = [];\r\n    private chunkMap : Chunk[][] = [];\r\n    private discardedChunks : Chunk[] = [];\r\n    private group : THREE.Group;\r\n    private waterGroup : THREE.Group;\r\n    private terrainGroup : THREE.Group;\r\n    private workerPool : WorkerPool;\r\n    private grassMesh : THREE.InstancedMesh;\r\n    private treeMesh : THREE.InstancedMesh;\r\n    private maxTreeDistance : number = 0;\r\n    private maxGrassDistance : number = 0;\r\n    private maxWorkers = 3;\r\n\r\n    constructor(scene : THREE.Scene) {\r\n        this.chunkRange = gameModel.settings.terrainSettings.chunkRange;\r\n        this.chunkSize = gameModel.settings.terrainSettings.chunkSize;\r\n        this.group = new THREE.Group();\r\n        scene.add(this.group);\r\n        this.waterGroup = new THREE.Group();\r\n        // this.waterGroup.add(staticWater);\r\n        this.waterGroup.add(waterPlane);\r\n        this.group.add(this.waterGroup);\r\n        this.terrainGroup = new THREE.Group();\r\n        this.group.add(this.terrainGroup);\r\n        this.grassMesh = getGrassMesh();\r\n        this.terrainGroup.add(this.grassMesh);\r\n        this.treeMesh = getTreeMesh();\r\n        this.terrainGroup.add(this.treeMesh);\r\n        let that = this;\r\n        this.workerPool = new WorkerPool(this.maxWorkers, function(event : MessageEvent) {\r\n            switch(event.data.type) {\r\n                case \"grass\":\r\n                    that.maxGrassDistance = event.data.maxDistance;\r\n                    that.processGrass(event.data.grassMatrices, event.data.grassTextures);\r\n                    break;\r\n                case \"tree\":\r\n                    that.maxTreeDistance = event.data.maxDistance;\r\n                    that.processTrees(event.data.treeMatrices);\r\n                    break;\r\n                case \"land\":\r\n                    // that.processChunk(event.data.x, event.data.y, event.data.pa, event.data.landTextures, event.data.normals, event.data.size);\r\n                    that.processChunk(event.data.x, event.data.y, event.data.pa, event.data.landTextures, event.data.size);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private createChunkObject (x : number, y : number) {\r\n        if (this.discardedChunks.length > 0) {\r\n            let chunk = this.discardedChunks.pop();\r\n            chunk.x = x;\r\n            chunk.y = y;\r\n            chunk.discarded = false;\r\n            chunk.processed = false;\r\n            return chunk;\r\n        }\r\n        let chunk = new Chunk(x , y, this.chunkSize);\r\n        this.terrainGroup.add(chunk.planeMesh);\r\n        chunk.processed = false;\r\n        return chunk;\r\n    }\r\n\r\n    private fixChunkNormals (chunk : Chunk) {\r\n        chunk.geo.computeBoundingSphere();\r\n        chunk.geo.computeVertexNormals();\r\n\r\n        let hVerts = this.chunkSize + 1;\r\n        let wVerts = this.chunkSize + 1;\r\n        let normals = chunk.geo.getAttribute(\"normal\");\r\n\r\n        let foreignChunk : Chunk\r\n        let foreignNormals : THREE.BufferAttribute | THREE.InterleavedBufferAttribute;\r\n        let foreignIndex : number;\r\n        if (this.chunkMap[chunk.x - this.chunkSize] && this.chunkMap[chunk.x - this.chunkSize][chunk.y]) {  // left side exists j = 0, i changes\r\n            foreignChunk = this.chunkMap[chunk.x - this.chunkSize][chunk.y];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < wVerts; i++) {\r\n                    foreignIndex = (hVerts - 1) * wVerts + i;\r\n                    normals.setXYZ(i, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x + this.chunkSize] && this.chunkMap[chunk.x + this.chunkSize][chunk.y]) {  // right side exists j = wVerts - 1, i changes\r\n            foreignChunk = this.chunkMap[chunk.x + this.chunkSize][chunk.y];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < wVerts; i++) {\r\n                    foreignIndex = i;\r\n                    normals.setXYZ((hVerts - 1) * wVerts + i, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x] && this.chunkMap[chunk.x][chunk.y + this.chunkSize]) {  // top side exists i = 0, j changes\r\n            foreignChunk = this.chunkMap[chunk.x][chunk.y + this.chunkSize];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < hVerts; i++) {\r\n                    foreignIndex = i * wVerts;\r\n                    normals.setXYZ(i * wVerts + (hVerts - 1), foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.chunkMap[chunk.x] && this.chunkMap[chunk.x][chunk.y - this.chunkSize]) {  // bottom side exists i = hVerts - 1, j changes\r\n            foreignChunk = this.chunkMap[chunk.x][chunk.y - this.chunkSize];\r\n            if (foreignChunk.processed) {\r\n                foreignNormals = foreignChunk.geo.getAttribute(\"normal\");\r\n                for (let i = 0; i < hVerts; i++) {\r\n                    foreignIndex = i * wVerts + (hVerts - 1);\r\n                    normals.setXYZ(i * wVerts, foreignNormals.getX(foreignIndex), foreignNormals.getY(foreignIndex), foreignNormals.getZ(foreignIndex));\r\n                }\r\n            }\r\n        }\r\n        let pos = chunk.geo.getAttribute(\"position\") as THREE.BufferAttribute;\r\n        pos.needsUpdate = true;\r\n    }\r\n\r\n    private processGrass(grassMatrices : [], grassTextures : []) {\r\n        let grassTextureArray = new Float32Array(grassTextures);\r\n        if (this.grassMesh.count < grassTextureArray.length)\r\n            return;\r\n        this.grassMesh.instanceMatrix.copyArray(new Float32Array(grassMatrices));\r\n        (this.grassMesh.geometry as THREE.PlaneBufferGeometry).setAttribute( 'tex', new THREE.InstancedBufferAttribute(grassTextureArray, 1, false, 1) );\r\n        this.grassMesh.instanceMatrix.needsUpdate = true;\r\n        this.treeMesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    private processTrees(treeMatrices : []) {\r\n        let treeMatrixArray = new Float32Array(treeMatrices);\r\n        if (this.treeMesh.count < treeMatrixArray.length / 16)\r\n            return;\r\n        this.treeMesh.instanceMatrix.copyArray(treeMatrixArray);\r\n        this.treeMesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    private processChunk(x : number, y : number, paData : [], landTextures : [],  size : number) {\r\n        if (size != this.chunkSize || !this.chunkMap[x] || !this.chunkMap[x][y])\r\n            return;\r\n\r\n        let chunk = this.chunkMap[x][y];\r\n        chunk.planeMesh.visible = false;\r\n        chunk.geo.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(paData), 3, false));\r\n        // chunk.geo.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(normals), 3, false));\r\n        chunk.geo.setAttribute(\"tex\", new THREE.BufferAttribute(new Float32Array(landTextures), 1, false));\r\n        this.fixChunkNormals(chunk);\r\n        chunk.processed = true;\r\n        chunk.planeMesh.visible = true;\r\n    }\r\n\r\n    private createChunk2 (x : number, y : number) {\r\n        let chunk = this.createChunkObject(x, y);\r\n        this.workerPool.getWorker().postMessage([\"land\", x, y, this.chunkSize]);\r\n        \r\n        this.chunks.push(chunk);\r\n        if (!this.chunkMap[x])\r\n            this.chunkMap[x] = [];\r\n\r\n        this.chunkMap[x][y] = chunk;\r\n    }\r\n\r\n    private destroyChunk(chunk : Chunk) {\r\n        chunk.discarded = true;\r\n        this.discardedChunks.push(chunk);\r\n        delete this.chunkMap[chunk.x][chunk.y];\r\n        if (Object.keys(this.chunkMap[chunk.x]).length == 0)\r\n            delete this.chunkMap[chunk.x];\r\n    }\r\n\r\n    private destroyAllChunks() {\r\n        for (var i = 0; i < this.chunks.length; i++) {\r\n            let chunk = this.chunks[i];\r\n            chunk.planeMesh.geometry.dispose();\r\n            this.terrainGroup.remove( chunk.planeMesh );\r\n        }\r\n        this.chunks = [];\r\n        this.discardedChunks = [];\r\n        this.chunkMap = [];\r\n    }\r\n\r\n    private updateSettings() {\r\n        this.chunkRange = gameModel.settings.terrainSettings.chunkRange;\r\n        this.chunkSize = gameModel.settings.terrainSettings.chunkSize;\r\n        gameModel.settings.terrainSettings.settingsChanged = false;\r\n        this.lastCubeCenter = { x: 1, y: 1 };\r\n        this.destroyAllChunks();\r\n    }\r\n\r\n    private updateDetailSettings() {\r\n        this.grassMesh.geometry.dispose();\r\n        this.terrainGroup.remove(this.grassMesh);\r\n        this.treeMesh.geometry.dispose();\r\n        this.terrainGroup.remove(this.treeMesh);\r\n        this.grassMesh = getGrassMesh();\r\n        this.terrainGroup.add(this.grassMesh);\r\n        this.treeMesh = getTreeMesh();\r\n        this.terrainGroup.add(this.treeMesh);\r\n        this.lastGrassCenter.x -= 50;\r\n        this.lastCubeCenter.x -= 2;\r\n        gameModel.settings.detailSettings.settingsChanged = false;\r\n    }\r\n\r\n    private lastCubeCenter = { x: 1, y: 1 };\r\n    private lastGrassCenter = {x : 0, y: 0};\r\n\r\n    private updateUniforms(timeDiff : number) {\r\n        uniforms.time.value += timeDiff * 60;\r\n        grassUniforms.time.value += timeDiff * 60;\r\n        if (grassUniforms.maxDistance.value > this.maxGrassDistance) {\r\n            grassUniforms.maxDistance.value -= 10 * timeDiff;\r\n        }\r\n        if (grassUniforms.maxDistance.value < this.maxGrassDistance) {\r\n            grassUniforms.maxDistance.value += 10 * timeDiff;\r\n        }\r\n        // console.log(this.maxGrassDistance);\r\n        // console.log(grassUniforms.maxDistance.value);\r\n        treeUniforms.time.value += timeDiff * 60;\r\n        if (treeUniforms.maxDistance.value > this.maxTreeDistance) {\r\n            treeUniforms.maxDistance.value -= 10 * timeDiff;\r\n        }\r\n        if (treeUniforms.maxDistance.value < this.maxTreeDistance) {\r\n            treeUniforms.maxDistance.value += 10 * timeDiff;\r\n        }\r\n    }\r\n\r\n    public updateChunks(timeDiff : number, camera : THREE.Camera) {\r\n\r\n        if (gameModel.settings.seedSettings.settingsChanged) {\r\n            gameModel.settings.seedSettings.settingsChanged = false;\r\n            if (!isNaN(gameModel.settings.seedSettings.seed)) {\r\n                for (let i = 0; i < this.maxWorkers; i++)\r\n                    this.workerPool.getWorker().postMessage([\"seed\", gameModel.settings.seedSettings.seed]);\r\n                noise.seed(gameModel.settings.seedSettings.seed);\r\n                this.lastGrassCenter.x -= 50;\r\n                this.lastCubeCenter.x -= 2;\r\n                camera.position.x = 0;\r\n                camera.position.z = 0;\r\n                this.destroyAllChunks();\r\n            }\r\n        }\r\n\r\n        if (gameModel.settings.terrainSettings.settingsChanged) {\r\n            this.updateSettings();\r\n        }\r\n        if (gameModel.settings.detailSettings.settingsChanged) {\r\n            this.updateDetailSettings();\r\n        }\r\n        this.updateUniforms(timeDiff);\r\n        let offsetX = Math.round(camera.position.x);\r\n        let offsetY = Math.round(camera.position.z);\r\n        if (Math.abs(offsetX - this.waterGroup.position.x) > 64 || Math.abs(offsetY - this.waterGroup.position.z) > 64) {\r\n            this.waterGroup.position.x = offsetX;\r\n            this.waterGroup.position.z = offsetY;\r\n        }\r\n\r\n        if (this.lastCubeCenter.x == offsetX && this.lastCubeCenter.y == offsetY)\r\n            return;\r\n\r\n        if (Math.abs(offsetX - this.lastGrassCenter.x) > 3 || Math.abs(offsetY - this.lastGrassCenter.y) > 3) {\r\n            this.workerPool.getWorker().postMessage([\"grass\", offsetX, offsetY, gameModel.settings.detailSettings.grassDensity,\r\n                gameModel.settings.detailSettings.grassNumber]);\r\n            this.workerPool.getWorker().postMessage([\"tree\", offsetX, offsetY, gameModel.settings.detailSettings.treeNumber]);\r\n            this.lastGrassCenter.x = offsetX;\r\n            this.lastGrassCenter.y = offsetY;\r\n        }\r\n\r\n        let centerChunk = {\r\n            x: Math.round(offsetX / this.chunkSize) * this.chunkSize,\r\n            y: Math.round(offsetY / this.chunkSize) * this.chunkSize,\r\n        }\r\n        var minX = centerChunk.x - (this.chunkRange * this.chunkSize);\r\n        var maxX = centerChunk.x + (this.chunkRange * this.chunkSize);\r\n        var minY = centerChunk.y - (this.chunkRange * this.chunkSize);\r\n        let maxY = centerChunk.y + (this.chunkRange * this.chunkSize);\r\n        for (var i = 0; i < this.chunks.length; i++) {\r\n            if (this.chunks[i].x < minX || this.chunks[i].x > maxX || this.chunks[i].y < minY || this.chunks[i].y > maxY) {\r\n                this.destroyChunk(this.chunks[i]);\r\n                this.chunks.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n        for (var i = -this.chunkRange; i <= this.chunkRange; i++) {\r\n            var x = centerChunk.x + (i * this.chunkSize);\r\n            for (var j = -this.chunkRange; j <= this.chunkRange; j++) {\r\n                var y = centerChunk.y + (j * this.chunkSize);\r\n                if (!this.chunkMap[x] || !this.chunkMap[x][y]) {\r\n                    this.createChunk2(x, y);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.lastCubeCenter.x = offsetX;\r\n        this.lastCubeCenter.y = offsetY;\r\n    }\r\n}","export const MyShaders = {\r\n\r\n  TreeVertexShader: `\r\n          #define MYGRASS\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n\r\n          varying vec3 vUv;\r\n          uniform float time;\r\n          uniform float amp;\r\n          uniform float maxDistance;\r\n          varying float fade;\r\n\r\n          void main() {\r\n\r\n              vUv = position;\r\n      \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              \r\n              vec4 mvPosition = vec4( transformed, 1.0 );\r\n              if (position.y > 1.0) {\r\n                float freq = 0.01;\r\n                float angle = time * freq;\r\n                angle += instanceMatrix[3].x;\r\n                mvPosition.z += cos(angle) * amp * position.y;\r\n              }\r\n\r\n              #ifdef USE_INSTANCING\r\n                mvPosition = instanceMatrix * mvPosition;\r\n              #endif\r\n\r\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\r\n\r\n              mvPosition = modelViewMatrix * mvPosition;              \r\n              gl_Position = projectionMatrix * mvPosition;\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n\r\n              fade = 1.0;             \r\n\r\n              if (dist > maxDistance * 0.9) {\r\n                if (dist > maxDistance) {\r\n                  fade = 0.0;\r\n                } else {\r\n                  fade = ((maxDistance - dist) / (maxDistance * 0.1));\r\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\r\n                }\r\n              }\r\n\r\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\t            // gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  TreeFragmentShader: `\r\n      uniform vec3 diffuse;\r\n      uniform vec3 emissive;\r\n      uniform float opacity;\r\n      varying vec3 vLightFront;\r\n      varying vec3 vIndirectFront;\r\n      #ifdef DOUBLE_SIDED\r\n          varying vec3 vLightBack;\r\n          varying vec3 vIndirectBack;\r\n      #endif\r\n      #include <common>\r\n      #include <packing>\r\n      #include <dithering_pars_fragment>\r\n      #include <color_pars_fragment>\r\n      #include <uv_pars_fragment>\r\n      #include <uv2_pars_fragment>\r\n      #include <map_pars_fragment>\r\n      #include <alphamap_pars_fragment>\r\n      #include <aomap_pars_fragment>\r\n      #include <lightmap_pars_fragment>\r\n      #include <emissivemap_pars_fragment>\r\n      #include <envmap_common_pars_fragment>\r\n      #include <envmap_pars_fragment>\r\n      #include <cube_uv_reflection_fragment>\r\n      #include <bsdfs>\r\n      #include <lights_pars_begin>\r\n      #include <fog_pars_fragment>\r\n      #include <shadowmap_pars_fragment>\r\n      #include <shadowmask_pars_fragment>\r\n      #include <specularmap_pars_fragment>\r\n      #include <logdepthbuf_pars_fragment>\r\n      #include <clipping_planes_pars_fragment>\r\n\r\n      varying vec3 vUv;\r\n      varying float fade;\r\n      \r\n      void main() {\r\n          #include <clipping_planes_fragment>\r\n\r\n          vec4 diffuseColor = vec4( diffuse, opacity );\r\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n          vec3 totalEmissiveRadiance = emissive;\r\n          #include <logdepthbuf_fragment>\r\n          #include <map_fragment>\r\n          #include <color_fragment>\r\n          #include <alphamap_fragment>\r\n          #include <alphatest_fragment>\r\n          #include <specularmap_fragment>\r\n          #include <emissivemap_fragment>\r\n          reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n          #ifdef DOUBLE_SIDED\r\n              reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n          #else\r\n              reflectedLight.indirectDiffuse += vIndirectFront;\r\n          #endif\r\n          #include <lightmap_fragment>\r\n          reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n          #ifdef DOUBLE_SIDED\r\n              reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n          #else\r\n              reflectedLight.directDiffuse = vLightFront;\r\n          #endif\r\n          reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n          #include <aomap_fragment>\r\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n          #include <envmap_fragment>\r\n          if (fade < 1.0) {\r\n            diffuseColor.a = fade;\r\n          }\r\n          gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n          #include <tonemapping_fragment>\r\n          #include <encodings_fragment>\r\n          #include <fog_fragment>\r\n          #include <premultiplied_alpha_fragment>\r\n          #include <dithering_fragment>\r\n      }\r\n    `,\r\n\r\n  GrassVertexShader: `\r\n          #define MYGRASS\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n\r\n          varying vec3 vUv;\r\n          attribute float tex;\r\n          varying float texFloat;\r\n          uniform float time;\r\n          uniform float amp;\r\n          uniform float maxDistance;\r\n          varying float fade;\r\n\r\n          void main() {\r\n\r\n              vUv = position;\r\n              texFloat = tex;\r\n      \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              \r\n              vec4 mvPosition = vec4( transformed, 1.0 );\r\n              if (position.y > 0.0) {\r\n                float freq = 0.2 * min(max(instanceMatrix[0].x, 0.7), 1.8);\r\n                float angle = ((time * 0.2) + (position.y * 8.0)) * freq;\r\n                angle += instanceMatrix[3].x;\r\n                mvPosition.z += cos(angle) * amp * freq;\r\n              }\r\n\r\n              #ifdef USE_INSTANCING\r\n                mvPosition = instanceMatrix * mvPosition;\r\n              #endif\r\n\r\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\r\n\r\n              mvPosition = modelViewMatrix * mvPosition;              \r\n              gl_Position = projectionMatrix * mvPosition;\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n\r\n              fade = 1.0;             \r\n\r\n              if (dist > maxDistance * 0.5) {\r\n                if (dist > maxDistance) {\r\n                  fade = 0.0;\r\n                } else {\r\n                  fade = ((maxDistance - dist) / (maxDistance * 0.5));\r\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\r\n                }\r\n              }\r\n\r\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\t            // gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  GrassFragmentShader: `\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform float opacity;\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <fog_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <shadowmask_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n  \r\n          uniform sampler2D texture1;\r\n          uniform sampler2D texture2;\r\n          uniform sampler2D texture3;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n          varying float fade;\r\n          \r\n          void main() {\r\n              #include <clipping_planes_fragment>\r\n  \r\n              vec4 diffuseColor = vec4(0.0,0.0,0.0,0.0);\r\n\r\n              if (texFloat < 0.3) {\r\n                diffuseColor = texture2D(texture1, 1.6 * vUv.xy + vec2(.51, .51));\r\n              } else if (texFloat > 0.7) {\r\n                diffuseColor = texture2D(texture2, 1.8 * vUv.xy + vec2(.51, .51));\r\n              } else {\r\n                diffuseColor = texture2D(texture3, 1.8 * vUv.xy + vec2(.53, .51));\r\n              }\r\n  \r\n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n              vec3 totalEmissiveRadiance = emissive;\r\n              #include <logdepthbuf_fragment>\r\n              #include <map_fragment>\r\n              #include <color_fragment>\r\n              #include <alphamap_fragment>\r\n              #include <alphatest_fragment>\r\n              #include <specularmap_fragment>\r\n              #include <emissivemap_fragment>\r\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n              #else\r\n                  reflectedLight.indirectDiffuse += vIndirectFront;\r\n              #endif\r\n              #include <lightmap_fragment>\r\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n              #else\r\n                  reflectedLight.directDiffuse = vLightFront;\r\n              #endif\r\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n              #include <aomap_fragment>\r\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n              #include <envmap_fragment>\r\n              if (fade < 1.0) {\r\n                diffuseColor.a = fade;\r\n              }\r\n              gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n              #include <tonemapping_fragment>\r\n              #include <encodings_fragment>\r\n              #include <fog_fragment>\r\n              #include <premultiplied_alpha_fragment>\r\n              #include <dithering_fragment>\r\n          }\r\n      `,\r\n\r\n  LandVertexShader: `\r\n          #define MYLAND\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n          attribute float tex;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n          void main() {\r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              #include <project_vertex>\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <lights_lambert_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n  \r\n              vUv = position;\r\n              texFloat = tex;\r\n          }\r\n      `,\r\n\r\n  LandFragmentShader: `\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform float opacity;\r\n          varying vec3 vLightFront;\r\n          varying vec3 vIndirectFront;\r\n          #ifdef DOUBLE_SIDED\r\n              varying vec3 vLightBack;\r\n              varying vec3 vIndirectBack;\r\n          #endif\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <fog_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <shadowmask_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n\r\n          uniform sampler2D grassTexture;\r\n          uniform sampler2D sandTexture;\r\n          uniform sampler2D gravelTexture;\r\n          uniform sampler2D snowTexture;\r\n          varying vec3 vUv;\r\n          varying float texFloat;\r\n  \r\n          void main() {\r\n              #include <clipping_planes_fragment>\r\n\r\n              vec4 color = vec4(0.0,0.0,0.0,0.0);\r\n              float tScale = 1.0;\r\n\r\n              if (texFloat > 0.0 && texFloat <= 1.0) {\r\n                color = mix(color, texture2D(sandTexture, vUv.xz * tScale), texFloat);\r\n              }\r\n              if (texFloat > 1.0 && texFloat <= 2.0) {\r\n                color = texture2D(sandTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(grassTexture, vUv.xz * tScale), texFloat - 1.0);\r\n              }\r\n              if (texFloat > 2.0 && texFloat <= 3.0) {\r\n                color = texture2D(grassTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(gravelTexture, vUv.xz * tScale), texFloat - 2.0);\r\n              }\r\n              if (texFloat > 3.0 && texFloat <= 4.0) {\r\n                color = texture2D(gravelTexture, vUv.xz * tScale);\r\n                color = mix(color, texture2D(snowTexture, vUv.xz * tScale), texFloat - 3.0);\r\n              }\r\n  \r\n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n              vec3 totalEmissiveRadiance = emissive;\r\n              #include <logdepthbuf_fragment>\r\n              #include <map_fragment>\r\n              #include <color_fragment>\r\n              #include <alphamap_fragment>\r\n              #include <alphatest_fragment>\r\n              #include <specularmap_fragment>\r\n              #include <emissivemap_fragment>\r\n              //reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\r\n              #else\r\n                  reflectedLight.indirectDiffuse += vIndirectFront;\r\n              #endif\r\n              #include <lightmap_fragment>\r\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( color.rgb );\r\n              #ifdef DOUBLE_SIDED\r\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n              #else\r\n                  reflectedLight.directDiffuse = vLightFront;\r\n              #endif\r\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( color.rgb ) * getShadowMask();\r\n              #include <aomap_fragment>\r\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n              #include <envmap_fragment>\r\n              gl_FragColor = vec4( outgoingLight, color.a );\r\n              #include <tonemapping_fragment>\r\n              #include <encodings_fragment>\r\n              #include <fog_fragment>\r\n              #include <premultiplied_alpha_fragment>\r\n              #include <dithering_fragment>\r\n          }\r\n      `,\r\n\r\n  WaterVertexShader: `\r\n          #define MYWATER\r\n          varying vec3 vViewPosition;\r\n          #ifndef FLAT_SHADED\r\n              varying vec3 vNormal;\r\n          #endif\r\n          #include <common>\r\n          #include <uv_pars_vertex>\r\n          #include <uv2_pars_vertex>\r\n          #include <displacementmap_pars_vertex>\r\n          #include <envmap_pars_vertex>\r\n          #include <color_pars_vertex>\r\n          #include <fog_pars_vertex>\r\n          #include <morphtarget_pars_vertex>\r\n          #include <skinning_pars_vertex>\r\n          #include <shadowmap_pars_vertex>\r\n          #include <logdepthbuf_pars_vertex>\r\n          #include <clipping_planes_pars_vertex>\r\n  \r\n          varying vec3 vUv;\r\n          uniform float time;\r\n          uniform float amp;\r\n  \r\n          void main() {\r\n              vUv = position; \r\n              #include <uv_vertex>\r\n              #include <uv2_vertex>\r\n              #include <color_vertex>\r\n              #include <beginnormal_vertex>\r\n              #include <morphnormal_vertex>\r\n              #include <skinbase_vertex>\r\n              #include <skinnormal_vertex>\r\n              #include <defaultnormal_vertex>\r\n          #ifndef FLAT_SHADED\r\n              vNormal = normalize( transformedNormal );\r\n          #endif\r\n              #include <begin_vertex>\r\n              #include <morphtarget_vertex>\r\n              #include <skinning_vertex>\r\n              #include <displacementmap_vertex>\r\n              #include <project_vertex>\r\n              #include <logdepthbuf_vertex>\r\n              #include <clipping_planes_vertex>\r\n              vViewPosition = - mvPosition.xyz;\r\n              #include <worldpos_vertex>\r\n              #include <envmap_vertex>\r\n              #include <shadowmap_vertex>\r\n              #include <fog_vertex>\r\n  \r\n            vNormal = normalMatrix * normal;\r\n            //float freq = 0.3;\r\n            //float angle = ((time * 0.2) + (position.x * 8.0))*freq;\r\n            //vUv.z += sin(angle)*amp;\r\n            //vNormal = normalMatrix * normalize(vec3(-amp * freq * cos(angle),0.0,1.0));\r\n            vec4 modelViewPosition = modelViewMatrix * vec4(vUv, 1.0);\r\n            gl_Position = projectionMatrix * modelViewPosition;\r\n          }\r\n      `,\r\n\r\n  WaterFragmentShader: `\r\n          #define MYWATER\r\n          uniform vec3 diffuse;\r\n          uniform vec3 emissive;\r\n          uniform vec3 specular;\r\n          uniform float shininess;\r\n          uniform float opacity;\r\n          #include <common>\r\n          #include <packing>\r\n          #include <dithering_pars_fragment>\r\n          #include <color_pars_fragment>\r\n          #include <uv_pars_fragment>\r\n          #include <uv2_pars_fragment>\r\n          #include <map_pars_fragment>\r\n          #include <alphamap_pars_fragment>\r\n          #include <aomap_pars_fragment>\r\n          #include <lightmap_pars_fragment>\r\n          #include <emissivemap_pars_fragment>\r\n          #include <envmap_common_pars_fragment>\r\n          #include <envmap_pars_fragment>\r\n          #include <cube_uv_reflection_fragment>\r\n          #include <fog_pars_fragment>\r\n          #include <bsdfs>\r\n          #include <lights_pars_begin>\r\n          #include <lights_phong_pars_fragment>\r\n          #include <shadowmap_pars_fragment>\r\n          #include <bumpmap_pars_fragment>\r\n          #include <normalmap_pars_fragment>\r\n          #include <specularmap_pars_fragment>\r\n          #include <logdepthbuf_pars_fragment>\r\n          #include <clipping_planes_pars_fragment>\r\n  \r\n          varying vec3 vPos;\r\n          uniform float time;\r\n          uniform sampler2D texture1;\r\n              varying vec3 vUv;\r\n\r\n          float noise(vec2 n) {\r\n              const vec2 d = vec2(0.0, 1.0);\r\n                vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\r\n              return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\r\n          }\r\n          \r\n          void main() {\r\n            #include <clipping_planes_fragment>\r\n            // compute moving color            \r\n  \r\n            // Compute the ripple effect.\r\n            float mod1 = 16.0;\r\n            float mod2 = 0.4;\r\n            float xoffset = 0.05 * cos(time / 52.0 + mod1 * vUv.y) + 0.09 * cos(time / 65.0 + mod2 * vUv.y);\r\n            float time2 = time + 0.8;\r\n            float yoffset = 0.02 * cos(time2 / 35.0 + mod1 * vUv.x) + 0.07 * cos(time2 / 55.0 + mod2 * vUv.x);\r\n            vec4 diffuseColor = texture2D(texture1, vec2((vUv.x + xoffset) * 0.25, (vUv.y + yoffset) * 0.25));\r\n            // vec4 diffuseColor = texture2D(texture1, vUv.xy + (time  * 0.001));\r\n            \r\n            //vec4 diffuseColor = vec4( diffuse, opacity );\r\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n            vec3 totalEmissiveRadiance = emissive;\r\n            #include <logdepthbuf_fragment>\r\n            #include <map_fragment>\r\n            #include <color_fragment>\r\n            #include <alphamap_fragment>\r\n            #include <alphatest_fragment>\r\n            #include <specularmap_fragment>\r\n            #include <normal_fragment_begin>\r\n            float nr = noise(vec2(vUv.x + (time * 0.01) + 2.0, vUv.y) * 3.0) - 0.5;\r\n            float nr2 = noise(vec2(vUv.x, vUv.y + (time * 0.01)) * 3.5) - 0.5;\r\n            float res = mix(nr, nr2, 0.5);\r\n            // normal.z = normal.z - 0.1 + (nr * 0.1 * cos((time + (vUv.x + vUv.y) * 10.0)/ 25.0));\r\n            if (res > 0.0) {\r\n              normal.z = normal.z - 0.1 + res * 0.2;\r\n            } else {\r\n              normal.z = normal.z - 0.1;\r\n            }\r\n\r\n            #include <normal_fragment_maps>\r\n            #include <emissivemap_fragment> \r\n            #include <lights_phong_fragment>\r\n            #include <lights_fragment_begin>\r\n            #include <lights_fragment_maps>\r\n            #include <lights_fragment_end>\r\n            #include <aomap_fragment>\r\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n            #include <envmap_fragment>\r\n            gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n            #include <tonemapping_fragment>\r\n            #include <encodings_fragment>\r\n            #include <fog_fragment>\r\n            #include <premultiplied_alpha_fragment>\r\n            #include <dithering_fragment>\r\n            gl_FragColor.a = 0.9;\r\n          }\r\n      `\r\n}","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"terrain-worker.js\");\n};","// three.js\r\nimport * as THREE from 'three';\r\n\r\nexport class MyCamera {\r\n\r\n    public camera : THREE.PerspectiveCamera;\r\n\r\n    constructor(scene : THREE.Scene) {\r\n        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);\r\n        // this.camera.rotation.y = Math.PI;\r\n        this.camera.position.x = 96;\r\n        this.camera.position.y = -100000;\r\n        this.camera.position.z = 33;\r\n        scene.add(this.camera);\r\n    }\r\n    \r\n}","import { MyCamera } from \"./camera\";\r\nimport { Vehicle, Walking } from \"./vehicles\";\r\n\r\nexport class Controls {\r\n\r\n\tpublic flashLight : boolean = true;\r\n\r\n\tpublic camera : MyCamera\r\n\tpublic currentVehicle : Vehicle\r\n\tpublic lastVehicle : Vehicle\r\n\tpublic vehicleWalking : Walking\r\n\r\n\tpublic handleMovement(timeDiff : number) {\r\n\t\tthis.currentVehicle.handleMovement(timeDiff);\r\n\t}\r\n    \r\n    constructor(myCamera : MyCamera) {\r\n\t\tthis.camera = myCamera;\r\n\t\tthis.vehicleWalking = new Walking(this.camera.camera, this);\r\n\t\tthis.currentVehicle = this.vehicleWalking;\r\n    }\r\n}","import { Controls } from \"./controls\";\r\nimport { getHeight } from \"../terrain/utils\";\r\nimport { isWater } from \"../terrain/terrain\";\r\n\r\nexport class Vehicle {\r\n    speed : THREE.Vector2;\r\n    acceleration : number;\r\n    drag : number;\r\n    turnSpeed : number;\r\n    preferredZoom : number;\r\n    camera : THREE.PerspectiveCamera;\r\n    controls : Controls;\r\n    handleMovement(timeDiff : number) : void {\r\n\r\n    }\r\n    onInit() : void {\r\n\r\n    }\r\n    onDestroy() : void {\r\n\r\n    }\r\n}\r\n\r\nexport class Walking extends Vehicle {\r\n    speed : THREE.Vector2 = new THREE.Vector2(0,4);\r\n    preferredZoom: number = 12;\r\n    constructor(camera : THREE.PerspectiveCamera, controls : Controls) {\r\n        super();\r\n        this.camera = camera;\r\n        this.controls = controls;\r\n    }\r\n    handleMovement(timeDiff: number): void {\r\n\r\n        this.camera.rotation.x = -0.7;\r\n\r\n        this.camera.position.x += this.speed.x * timeDiff;\r\n        this.camera.position.z -= this.speed.y * timeDiff;\r\n\r\n        let height = getHeight(this.camera.position.x, this.camera.position.z);\r\n        \r\n        var diff = (height + this.preferredZoom) - this.camera.position.y;\r\n        if (diff > 0) {\r\n            this.camera.position.y += diff * timeDiff * 5;\r\n        } else {\r\n            this.camera.position.y += diff * timeDiff * 5;\r\n        }\r\n    }\r\n}"],"sourceRoot":""}