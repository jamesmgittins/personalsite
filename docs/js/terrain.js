!function(e){var n={};function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(n){return e[n]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=4)}([function(e,n){e.exports=THREE},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.maximumGrass=n.maximumTrees=n.noiseSeed=n.chunkRange=n.chunkSize=n.mountainMod=n.heights=void 0,n.heights={water:4.3,sand:5,plainsMin:4,plainsMax:35,mountainFactor:1.6},n.mountainMod=n.heights.plainsMax-(n.heights.plainsMin+(n.heights.plainsMax-n.heights.plainsMin)/4),n.chunkSize={x:128,y:128},n.chunkRange=3,n.noiseSeed=1024,n.maximumTrees=500,n.maximumGrass=2e3},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getTreeGeometery=n.getLandTexture=n.getHeight=void 0;const i=t(1),r=i.heights.plainsMin+(i.heights.plainsMax-i.heights.plainsMin)/4;n.getHeight=function(e,n){let t=.5*noise.simplex2(e/8,n/8)+2*noise.simplex2(e/32,n/32)+10*noise.simplex2(e/100,n/100)+32*noise.simplex2(e/200,n/200)+32*noise.simplex2(e/500,n/500)+24*noise.simplex2(e/900,n/900);t+=30;let a=i.heights.plainsMin+(t-i.heights.plainsMin)/4;return t>i.heights.plainsMax?Math.pow(a-r,i.heights.mountainFactor)+r:a},n.getLandTexture=function(e,n,t){if(t<i.heights.water-1)return 0+Math.max(t-(i.heights.water-2),0);if(t<i.heights.sand+.5)return 1;if(t<i.heights.sand+1)return 1+2*(t-(i.heights.sand+.5));let r=3+3*noise.simplex2(e/20,n/20);if(t>i.heights.plainsMax+5+r)return 4;if(t>i.heights.plainsMax+3+r)return 3+.5*(t-(i.heights.plainsMax+3+r));let a=5+5*noise.simplex2(e/15,n/15);return t>i.mountainMod+a?3:t>i.mountainMod+a-2?2+.5*(t-(i.mountainMod+a-2)):2},n.getTreeGeometery=function(){const e=new THREE.Color(3242032),n=new THREE.Color(7222822),t=new THREE.Geometry,i=new THREE.ConeGeometry(.8,1.6,10);i.faces.forEach(n=>n.color.set(e)),i.translate(0,3.7,0),t.merge(i);const r=new THREE.ConeGeometry(1,1.8,10);r.faces.forEach(n=>n.color.set(e)),r.translate(0,2.9,0),t.merge(r);const a=new THREE.ConeGeometry(1.2,2,10);a.faces.forEach(n=>n.color.set(e)),a.translate(0,2,0),t.merge(a);const s=new THREE.CylinderGeometry(.3,.3,2);s.translate(0,-0,0),s.faces.forEach(e=>e.color.set(n)),t.merge(s);let o=new THREE.BufferGeometry;return o.fromGeometry(t),o}},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.getGameModel=void 0;const s=a(t(1));const o=new class{constructor(){this.settings={terrainSettings:{settingsChanged:!0,chunkSize:s.chunkSize.x,chunkRange:4},detailSettings:{settingsChanged:!1,treeNumber:1e3,grassNumber:2e4,grassDensity:.25},rendererSettings:{settingsChanged:!1,antialias:!1,resolution:1},seedSettings:{seed:s.noiseSeed,settingsChanged:!1}}}};n.getGameModel=function(){return o}},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.startApplication=void 0;const s=a(t(0)),o=a(t(5)),c=a(t(8)),l=t(9),u=t(3);function d(){u.getGameModel();const e=new s.Scene,n=new c.MyCamera(e),t=new l.Controls(n),i=new s.WebGLRenderer({antialias:!1});window.matchMedia("(pointer: coarse)").matches&&i.setPixelRatio(window.devicePixelRatio);let r=new o.Terrain(e,()=>{document.getElementById("canvas-container").classList.add("ready"),setTimeout((function(){document.getElementById("canvas-container").classList.add("finished")}),13e3)});i.setSize(window.innerWidth,window.innerHeight),e.background=new s.Color(0,0,0),document.getElementById("canvas-container").appendChild(i.domElement);let a=new s.Group;e.add(a);const d=new s.Color(16777181);let f=new s.DirectionalLight(d,.6);f.position.y=3e3,f.position.z=1e3,f.target=n.camera,a.add(f);let m=0,g=0;!function a(){requestAnimationFrame(a),function(){m=Date.now();let a=Math.min((m-g)/1e3,1);g=m,r.updateChunks(a,n.camera),t.handleMovement(a),i.render(e,n.camera)}()}(),window.onresize=function(){n.camera.aspect=window.innerWidth/window.innerHeight,n.camera.updateProjectionMatrix(),i.setSize(window.innerWidth,window.innerHeight)}}n.startApplication=d,d()},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Terrain=n.isWater=void 0;const o=a(t(0)),c=t(6),l=s(t(7)),u=t(1),d=t(2),f=t(3).getGameModel();noise.seed(f.settings.seedSettings.seed);const m=(new o.TextureLoader).load("img/grass.png"),g=(new o.TextureLoader).load("img/grassblade.png"),h=(new o.TextureLoader).load("img/grassblade2.png"),p=(new o.TextureLoader).load("img/grassblade3.png"),v=(new o.TextureLoader).load("img/gravel.png"),_=(new o.TextureLoader).load("img/sand.png"),x=(new o.TextureLoader).load("img/water.jpg"),y=(new o.TextureLoader).load("img/snow.png");x.wrapS=o.MirroredRepeatWrapping,x.wrapT=o.MirroredRepeatWrapping,x.wrapT=o.RepeatWrapping,v.wrapS=y.wrapS=_.wrapS=m.wrapS=o.RepeatWrapping,v.wrapT=y.wrapT=_.wrapT=m.wrapT=o.RepeatWrapping,v.magFilter=y.magFilter=_.magFilter=m.magFilter=o.NearestFilter;const b=o.UniformsUtils.merge([o.ShaderLib.phong.uniforms]);b.texture1={type:"t",value:x},b.time={type:"f",value:1},b.amp={type:"f",value:.004};const k=new o.ShaderMaterial({uniforms:b,vertexShader:c.MyShaders.WaterVertexShader,fragmentShader:c.MyShaders.WaterFragmentShader,lights:!0,transparent:!0,alphaTest:.5}),M=o.UniformsUtils.merge([o.ShaderLib.standard.uniforms]);M.grassTexture={type:"t",value:m},M.sandTexture={type:"t",value:_},M.snowTexture={type:"t",value:y},M.gravelTexture={type:"t",value:v};const w=o.UniformsUtils.merge([o.ShaderLib.lambert.uniforms]);w.texture1={type:"t",value:g},w.texture2={type:"t",value:h},w.texture3={type:"t",value:p},w.time={type:"f",value:0},w.amp={type:"f",value:.5},w.maxDistance={type:"f",value:30};const D=o.UniformsUtils.merge([o.ShaderLib.lambert.uniforms]);D.time={type:"f",value:0},D.amp={type:"f",value:.05},D.maxDistance={type:"f",value:30};let S=new o.ShaderMaterial({uniforms:M,vertexShader:c.MyShaders.LandVertexShader,fragmentShader:c.MyShaders.LandFragmentShader,lights:!0,side:o.BackSide});var L=new o.PlaneBufferGeometry(4e3,4e3,1,1),F=new o.Mesh(L,k);F.position.y=u.heights.water+.55,F.rotation.x=-.5*Math.PI;var C=new o.PlaneBufferGeometry(6400,6400,1,1),P=new o.Mesh(C,new o.MeshPhongMaterial({map:x}));P.position.y=u.heights.water+.5,P.rotation.x=-.5*Math.PI,n.isWater=function(e){return e<F.position.y};class T{constructor(e,n){this.workers=[],this.counter=0,this.maxWorkers=1,this.maxWorkers=e,this.onMessage=n}getWorker(){if(this.workers.length<this.maxWorkers){let e=new l.default;e.onmessage=this.onMessage,this.workers.push(e)}return this.counter++,this.counter>this.workers.length-1&&(this.counter=0),this.workers[this.counter]}}class z{constructor(e,n,t){this.x=e,this.y=n,this.geo=new o.PlaneBufferGeometry(t,t,t,t),this.planeMesh=new o.Mesh(this.geo,S),this.discarded=!1}}n.Terrain=class{constructor(e,n){this.chunkRange=3,this.chunkSize=32,this.chunks=[],this.chunkMap=[],this.discardedChunks=[],this.maxTreeDistance=0,this.maxGrassDistance=0,this.maxWorkers=3,this.called=!1,this.lastCubeCenter={x:1,y:1},this.lastGrassCenter={x:0,y:0},this.chunkRange=f.settings.terrainSettings.chunkRange,this.chunkSize=f.settings.terrainSettings.chunkSize,this.group=new o.Group,e.add(this.group),this.waterGroup=new o.Group,this.waterGroup.add(F),this.group.add(this.waterGroup),this.terrainGroup=new o.Group,this.group.add(this.terrainGroup),this.grassMesh=function(){let e=new o.PlaneBufferGeometry(.5,.5);return new o.InstancedMesh(e,new o.ShaderMaterial({uniforms:w,side:o.DoubleSide,vertexShader:c.MyShaders.GrassVertexShader,fragmentShader:c.MyShaders.GrassFragmentShader,transparent:!0,alphaTest:.5,lights:!0}),f.settings.detailSettings.grassNumber)}(),this.terrainGroup.add(this.grassMesh),this.treeMesh=new o.InstancedMesh(d.getTreeGeometery(),new o.ShaderMaterial({uniforms:D,vertexColors:!0,vertexShader:c.MyShaders.TreeVertexShader,fragmentShader:c.MyShaders.TreeFragmentShader,lights:!0,transparent:!0,alphaTest:.5}),f.settings.detailSettings.treeNumber),this.terrainGroup.add(this.treeMesh),this.callback=n;let t=this;this.workerPool=new T(this.maxWorkers,(function(e){switch(e.data.type){case"grass":t.maxGrassDistance=e.data.maxDistance,t.processGrass(e.data.grassMatrices,e.data.grassTextures);break;case"tree":t.maxTreeDistance=e.data.maxDistance,t.processTrees(e.data.treeMatrices);break;case"land":t.processChunk(e.data.x,e.data.y,e.data.pa,e.data.landTextures,e.data.size)}}))}createChunkObject(e,n){if(this.discardedChunks.length>0){let t=this.discardedChunks.pop();return t.x=e,t.y=n,t.discarded=!1,t.processed=!1,t}let t=new z(e,n,this.chunkSize);return this.terrainGroup.add(t.planeMesh),t.processed=!1,t}fixChunkNormals(e){e.geo.computeBoundingSphere(),e.geo.computeVertexNormals();let n,t,i,r=this.chunkSize+1,a=this.chunkSize+1,s=e.geo.getAttribute("normal");if(this.chunkMap[e.x-this.chunkSize]&&this.chunkMap[e.x-this.chunkSize][e.y]&&(n=this.chunkMap[e.x-this.chunkSize][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)i=(r-1)*a+e,s.setXYZ(e,t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x+this.chunkSize]&&this.chunkMap[e.x+this.chunkSize][e.y]&&(n=this.chunkMap[e.x+this.chunkSize][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)i=e,s.setXYZ((r-1)*a+e,t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y+this.chunkSize]&&(n=this.chunkMap[e.x][e.y+this.chunkSize],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<r;e++)i=e*a,s.setXYZ(e*a+(r-1),t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y-this.chunkSize]&&(n=this.chunkMap[e.x][e.y-this.chunkSize],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<r;e++)i=e*a+(r-1),s.setXYZ(e*a,t.getX(i),t.getY(i),t.getZ(i))}e.geo.getAttribute("position").needsUpdate=!0}processGrass(e,n){let t=new Float32Array(n);this.grassMesh.count<t.length||(this.grassMesh.instanceMatrix.copyArray(new Float32Array(e)),this.grassMesh.geometry.setAttribute("tex",new o.InstancedBufferAttribute(t,1,!1,1)),this.grassMesh.instanceMatrix.needsUpdate=!0,this.treeMesh.instanceMatrix.needsUpdate=!0)}processTrees(e){let n=new Float32Array(e);this.treeMesh.count<n.length/16||(this.treeMesh.instanceMatrix.copyArray(n),this.treeMesh.instanceMatrix.needsUpdate=!0)}processChunk(e,n,t,i,r){if(r!=this.chunkSize||!this.chunkMap[e]||!this.chunkMap[e][n])return;let a=this.chunkMap[e][n];a.planeMesh.visible=!1,a.geo.setAttribute("position",new o.BufferAttribute(new Float32Array(t),3,!1)),a.geo.setAttribute("tex",new o.BufferAttribute(new Float32Array(i),1,!1)),this.fixChunkNormals(a),a.processed=!0,a.planeMesh.visible=!0}createChunk2(e,n){let t=this.createChunkObject(e,n);this.workerPool.getWorker().postMessage(["land",e,n,this.chunkSize]),this.chunks.push(t),this.chunkMap[e]||(this.chunkMap[e]=[]),this.chunkMap[e][n]=t}destroyChunk(e){e.discarded=!0,this.discardedChunks.push(e),delete this.chunkMap[e.x][e.y],0==Object.keys(this.chunkMap[e.x]).length&&delete this.chunkMap[e.x]}updateUniforms(e){b.time.value+=60*e,w.time.value+=60*e,w.maxDistance.value>this.maxGrassDistance&&(w.maxDistance.value-=10*e),w.maxDistance.value<this.maxGrassDistance&&(w.maxDistance.value+=10*e),D.time.value+=60*e,D.maxDistance.value>this.maxTreeDistance&&(D.maxDistance.value-=10*e),D.maxDistance.value<this.maxTreeDistance&&(D.maxDistance.value+=10*e)}updateChunks(e,n){this.updateUniforms(e);let t=Math.round(n.position.x),i=Math.round(n.position.z);if((Math.abs(t-this.waterGroup.position.x)>64||Math.abs(i-this.waterGroup.position.z)>64)&&(this.waterGroup.position.x=t,this.waterGroup.position.z=i),this.lastCubeCenter.x==t&&this.lastCubeCenter.y==i)return;(Math.abs(t-this.lastGrassCenter.x)>3||Math.abs(i-this.lastGrassCenter.y)>3)&&(this.workerPool.getWorker().postMessage(["grass",t,i,f.settings.detailSettings.grassDensity,f.settings.detailSettings.grassNumber]),this.workerPool.getWorker().postMessage(["tree",t,i,f.settings.detailSettings.treeNumber]),this.lastGrassCenter.x=t,this.lastGrassCenter.y=i);let r=Math.round(t/this.chunkSize)*this.chunkSize,a=Math.round(i/this.chunkSize)*this.chunkSize;var s=r-this.chunkRange*this.chunkSize,o=r+this.chunkRange*this.chunkSize,c=a-this.chunkRange*this.chunkSize;let l=a+this.chunkRange*this.chunkSize;for(var u=0;u<this.chunks.length;u++)if(this.chunks[u].x<s||this.chunks[u].x>o||this.chunks[u].y<c||this.chunks[u].y>l)return this.destroyChunk(this.chunks[u]),void this.chunks.splice(u,1);!this.called&&this.chunkMap[r]&&this.chunkMap[r][a]&&(this.called=!0,this.callback());for(u=-this.chunkRange;u<=this.chunkRange;u++)for(var d=r+u*this.chunkSize,m=-this.chunkRange;m<=0;m++){var g=a+m*this.chunkSize;if(!this.chunkMap[d]||!this.chunkMap[d][g])return void this.createChunk2(d,g)}this.lastCubeCenter.x=t,this.lastCubeCenter.y=i}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MyShaders=void 0,n.MyShaders={TreeVertexShader:"\n          #define MYGRASS\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n\n          varying vec3 vUv;\n          uniform float time;\n          uniform float amp;\n          uniform float maxDistance;\n          varying float fade;\n\n          void main() {\n\n              vUv = position;\n      \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              \n              vec4 mvPosition = vec4( transformed, 1.0 );\n              if (position.y > 1.0) {\n                float freq = 0.01;\n                float angle = time * freq;\n                angle += instanceMatrix[3].x;\n                mvPosition.z += cos(angle) * amp * position.y;\n              }\n\n              #ifdef USE_INSTANCING\n                mvPosition = instanceMatrix * mvPosition;\n              #endif\n\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\n\n              mvPosition = modelViewMatrix * mvPosition;              \n              gl_Position = projectionMatrix * mvPosition;\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n\n              fade = 1.0;             \n\n              if (dist > maxDistance * 0.9) {\n                if (dist > maxDistance) {\n                  fade = 0.0;\n                } else {\n                  fade = ((maxDistance - dist) / (maxDistance * 0.1));\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\n                }\n              }\n\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t            // gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",TreeFragmentShader:"\n      uniform vec3 diffuse;\n      uniform vec3 emissive;\n      uniform float opacity;\n      varying vec3 vLightFront;\n      varying vec3 vIndirectFront;\n      #ifdef DOUBLE_SIDED\n          varying vec3 vLightBack;\n          varying vec3 vIndirectBack;\n      #endif\n      #include <common>\n      #include <packing>\n      #include <dithering_pars_fragment>\n      #include <color_pars_fragment>\n      #include <uv_pars_fragment>\n      #include <uv2_pars_fragment>\n      #include <map_pars_fragment>\n      #include <alphamap_pars_fragment>\n      #include <aomap_pars_fragment>\n      #include <lightmap_pars_fragment>\n      #include <emissivemap_pars_fragment>\n      #include <envmap_common_pars_fragment>\n      #include <envmap_pars_fragment>\n      #include <cube_uv_reflection_fragment>\n      #include <bsdfs>\n      #include <lights_pars_begin>\n      #include <fog_pars_fragment>\n      #include <shadowmap_pars_fragment>\n      #include <shadowmask_pars_fragment>\n      #include <specularmap_pars_fragment>\n      #include <logdepthbuf_pars_fragment>\n      #include <clipping_planes_pars_fragment>\n\n      varying vec3 vUv;\n      varying float fade;\n      \n      void main() {\n          #include <clipping_planes_fragment>\n\n          vec4 diffuseColor = vec4( diffuse, opacity );\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n          vec3 totalEmissiveRadiance = emissive;\n          #include <logdepthbuf_fragment>\n          #include <map_fragment>\n          #include <color_fragment>\n          #include <alphamap_fragment>\n          #include <alphatest_fragment>\n          #include <specularmap_fragment>\n          #include <emissivemap_fragment>\n          reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n          #ifdef DOUBLE_SIDED\n              reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n          #else\n              reflectedLight.indirectDiffuse += vIndirectFront;\n          #endif\n          #include <lightmap_fragment>\n          reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n          #ifdef DOUBLE_SIDED\n              reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n          #else\n              reflectedLight.directDiffuse = vLightFront;\n          #endif\n          reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n          #include <aomap_fragment>\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n          #include <envmap_fragment>\n          if (fade < 1.0) {\n            diffuseColor.a = fade;\n          }\n          gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n          #include <dithering_fragment>\n      }\n    ",GrassVertexShader:"\n          #define MYGRASS\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n\n          varying vec3 vUv;\n          attribute float tex;\n          varying float texFloat;\n          uniform float time;\n          uniform float amp;\n          uniform float maxDistance;\n          varying float fade;\n\n          void main() {\n\n              vUv = position;\n              texFloat = tex;\n      \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              \n              vec4 mvPosition = vec4( transformed, 1.0 );\n              if (position.y > 0.0) {\n                float freq = 0.2 * min(max(instanceMatrix[0].x, 0.7), 1.8);\n                float angle = ((time * 0.2) + (position.y * 8.0)) * freq;\n                angle += instanceMatrix[3].x;\n                mvPosition.z += cos(angle) * amp * freq;\n              }\n\n              #ifdef USE_INSTANCING\n                mvPosition = instanceMatrix * mvPosition;\n              #endif\n\n              float dist = distance(vec3(mvPosition.x, 0.0, mvPosition.z), vec3(cameraPosition.x, 0.0, cameraPosition.z));\n\n              mvPosition = modelViewMatrix * mvPosition;              \n              gl_Position = projectionMatrix * mvPosition;\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n\n              fade = 1.0;             \n\n              if (dist > maxDistance * 0.5) {\n                if (dist > maxDistance) {\n                  fade = 0.0;\n                } else {\n                  fade = ((maxDistance - dist) / (maxDistance * 0.5));\n                  // fade = 1.0 + (mvPosition.z / maxDistance);\n                }\n              }\n\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t            // gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",GrassFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          uniform sampler2D texture1;\n          uniform sampler2D texture2;\n          uniform sampler2D texture3;\n          varying vec3 vUv;\n          varying float texFloat;\n          varying float fade;\n          \n          void main() {\n              #include <clipping_planes_fragment>\n  \n              vec4 diffuseColor = vec4(0.0,0.0,0.0,0.0);\n\n              if (texFloat < 0.3) {\n                diffuseColor = texture2D(texture1, 1.6 * vUv.xy + vec2(.51, .51));\n              } else if (texFloat > 0.7) {\n                diffuseColor = texture2D(texture2, 1.8 * vUv.xy + vec2(.51, .51));\n              } else {\n                diffuseColor = texture2D(texture3, 1.8 * vUv.xy + vec2(.53, .51));\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              if (fade < 1.0) {\n                diffuseColor.a = fade;\n              }\n              gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",LandVertexShader:"\n          #define MYLAND\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n          attribute float tex;\n          varying vec3 vUv;\n          varying float texFloat;\n          void main() {\n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n              vUv = position;\n              texFloat = tex;\n          }\n      ",LandFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n\n          uniform sampler2D grassTexture;\n          uniform sampler2D sandTexture;\n          uniform sampler2D gravelTexture;\n          uniform sampler2D snowTexture;\n          varying vec3 vUv;\n          varying float texFloat;\n  \n          void main() {\n              #include <clipping_planes_fragment>\n\n              vec4 color = vec4(0.0,0.0,0.0,0.0);\n              float tScale = 1.0;\n\n              if (texFloat > 0.0 && texFloat <= 1.0) {\n                color = mix(color, texture2D(sandTexture, vUv.xz * tScale), texFloat);\n              }\n              if (texFloat > 1.0 && texFloat <= 2.0) {\n                color = texture2D(sandTexture, vUv.xz * tScale);\n                color = mix(color, texture2D(grassTexture, vUv.xz * tScale), texFloat - 1.0);\n              }\n              if (texFloat > 2.0 && texFloat <= 3.0) {\n                color = texture2D(grassTexture, vUv.xz * tScale);\n                color = mix(color, texture2D(gravelTexture, vUv.xz * tScale), texFloat - 2.0);\n              }\n              if (texFloat > 3.0 && texFloat <= 4.0) {\n                color = texture2D(gravelTexture, vUv.xz * tScale);\n                color = mix(color, texture2D(snowTexture, vUv.xz * tScale), texFloat - 3.0);\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              //reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( color.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( color.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              gl_FragColor = vec4( outgoingLight, color.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",WaterVertexShader:"\n          #define MYWATER\n          varying vec3 vViewPosition;\n          #ifndef FLAT_SHADED\n              varying vec3 vNormal;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <displacementmap_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n  \n          varying vec3 vUv;\n          uniform float time;\n          uniform float amp;\n  \n          void main() {\n              vUv = position; \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n          #ifndef FLAT_SHADED\n              vNormal = normalize( transformedNormal );\n          #endif\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <displacementmap_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              vViewPosition = - mvPosition.xyz;\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n            vNormal = normalMatrix * normal;\n            //float freq = 0.3;\n            //float angle = ((time * 0.2) + (position.x * 8.0))*freq;\n            //vUv.z += sin(angle)*amp;\n            //vNormal = normalMatrix * normalize(vec3(-amp * freq * cos(angle),0.0,1.0));\n            vec4 modelViewPosition = modelViewMatrix * vec4(vUv, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",WaterFragmentShader:"\n          #define MYWATER\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform vec3 specular;\n          uniform float shininess;\n          uniform float opacity;\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <fog_pars_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <lights_phong_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <bumpmap_pars_fragment>\n          #include <normalmap_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          varying vec3 vPos;\n          uniform float time;\n          uniform sampler2D texture1;\n              varying vec3 vUv;\n\n          float noise(vec2 n) {\n              const vec2 d = vec2(0.0, 1.0);\n                vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n              return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n          }\n          \n          void main() {\n            #include <clipping_planes_fragment>\n            // compute moving color            \n  \n            // Compute the ripple effect.\n            float mod1 = 16.0;\n            float mod2 = 0.4;\n            float xoffset = 0.05 * cos(time / 52.0 + mod1 * vUv.y) + 0.09 * cos(time / 65.0 + mod2 * vUv.y);\n            float time2 = time + 0.8;\n            float yoffset = 0.02 * cos(time2 / 35.0 + mod1 * vUv.x) + 0.07 * cos(time2 / 55.0 + mod2 * vUv.x);\n            vec4 diffuseColor = texture2D(texture1, vec2((vUv.x + xoffset) * 0.25, (vUv.y + yoffset) * 0.25));\n            // vec4 diffuseColor = texture2D(texture1, vUv.xy + (time  * 0.001));\n            \n            //vec4 diffuseColor = vec4( diffuse, opacity );\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n            vec3 totalEmissiveRadiance = emissive;\n            #include <logdepthbuf_fragment>\n            #include <map_fragment>\n            #include <color_fragment>\n            #include <alphamap_fragment>\n            #include <alphatest_fragment>\n            #include <specularmap_fragment>\n            #include <normal_fragment_begin>\n            float nr = noise(vec2(vUv.x + (time * 0.01) + 2.0, vUv.y) * 3.0) - 0.5;\n            float nr2 = noise(vec2(vUv.x, vUv.y + (time * 0.01)) * 3.5) - 0.5;\n            float res = mix(nr, nr2, 0.5);\n            // normal.z = normal.z - 0.1 + (nr * 0.1 * cos((time + (vUv.x + vUv.y) * 10.0)/ 25.0));\n            if (res > 0.0) {\n              normal.z = normal.z - 0.1 + res * 0.2;\n            } else {\n              normal.z = normal.z - 0.1;\n            }\n\n            #include <normal_fragment_maps>\n            #include <emissivemap_fragment> \n            #include <lights_phong_fragment>\n            #include <lights_fragment_begin>\n            #include <lights_fragment_maps>\n            #include <lights_fragment_end>\n            #include <aomap_fragment>\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n            #include <envmap_fragment>\n            gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n            #include <fog_fragment>\n            #include <premultiplied_alpha_fragment>\n            #include <dithering_fragment>\n            gl_FragColor.a = 0.9;\n          }\n      "}},function(e,n,t){e.exports=function(){return new Worker(t.p+"terrain-worker.js")}},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.MyCamera=void 0;const s=a(t(0));n.MyCamera=class{constructor(e){this.camera=new s.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,3e3),this.camera.position.x=96,this.camera.position.y=-1e5,this.camera.position.z=33,e.add(this.camera)}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Controls=void 0;const i=t(10);n.Controls=class{constructor(e){this.flashLight=!0,this.camera=e,this.vehicleWalking=new i.Walking(this.camera.camera,this),this.currentVehicle=this.vehicleWalking}handleMovement(e){this.currentVehicle.handleMovement(e)}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Walking=n.Vehicle=void 0;const i=t(2);class r{handleMovement(e){}onInit(){}onDestroy(){}}n.Vehicle=r;n.Walking=class extends r{constructor(e,n){super(),this.speed=new THREE.Vector2(0,4),this.preferredZoom=12,this.camera=e,this.controls=n}handleMovement(e){this.camera.rotation.x=-.7,this.camera.position.x+=this.speed.x*e,this.camera.position.z-=this.speed.y*e;let n=i.getHeight(this.camera.position.x,this.camera.position.z);var t=n+this.preferredZoom-this.camera.position.y;Math.abs(t)>30?this.camera.position.y=n+this.preferredZoom:this.camera.position.y+=t*e*2}}}]);
//# sourceMappingURL=terrain.js.map